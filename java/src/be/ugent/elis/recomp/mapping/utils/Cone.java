/*
SOFTWARE LICENSE AGREEMENT

This software license agreement (hereinafter referred to as the "Agreement") provides the terms and conditions under which Universiteit Gent - Ghent University (hereinafter referred to as "UGent") is willing to grant you (being the person or entity installing and using the Licensed Software for Non-Commercial Purposes, hereinafter referred to as the "Licensee")  a non-exclusive, limited right to use the Licensed Software under UGent Copyright.

By downloading the Licensed Software, or installing Licensed Software, or using Licensed Software, or clicking on the "accept" button under this Agreement, Licensee agrees to accept the terms and conditions of this Agreement and agrees to be bound by this Agreement. If Licensee does not agree with any of the terms or conditions of this Agreement, he should not download or install or use the Licensed Software. 

(1) Licensee warrants and represents that the person accepting this Agreement on behalf of Licensee is its legally authorized representative and is duly authorized to accept agreements of this type on behalf of Licensee and obligate Licensee to the terms and conditions herein. Any breach of this warranty and representation is a material breach of this Agreement and, in such event, this Agreement and the rights granted to Licensee shall terminate automatically. 

(2) Definitions  -  For the purposes of this Agreement, the following terms shall have the following meanings:
a) "Software":  refers to the computer software supplied with this Agreement named "tlut flow" and provided in Python and Java code form. 
b) "Licensed Software":  refers to the Software, and any other computer software and documentation, if any, supplied with this Agreement. 
c) "Adaptation":  refers to any work based on the Licensed Software, including: 
    1) any work which incorporates all or part of the Licensed Software, 
    2) any work which includes modifications to the Software, including but not limited to bug fixes, 
    3) any work which would be regarded as a derivative work of the Software under the Belgian Copyright Law, and 
    4) any work which is otherwise covered by any of UGent's intellectual property rights in the Licensed Software. 
d) "Grant Back Software":  refers to any
        1) modification of the objects distributed as the Software, including but not limited to the addition, deletion, and modification of verbs and properties on the objects, 
        2) creation of children to the objects distributed as the Software. 
e) "Copyright Holder": refers to Universiteit Gent - Ghent University, public institution with legal personality, having its administrative offices in Belgium, B-9000 Gent, Sint-Pietersnieuwstraat 25 (herein also referred to as "UGent")
f) "Non-Commercial Purpose":  refers to use of the Licensed Software solely for the purpose of education or research. "Non-Commercial Purpose" excludes, without limitation, any use of the Software as part of or in connection with a product (including software) or service which is sold, offered for sale, licensed, leased, loaned or rented.

(3) Adaptations  -  Licensee may create Adaptations of the Licensed Software only if 
    a. Licensee treats the Adaptations as Licensed Software under this Agreement, and 
    b. the Adaptations include all copyright notices appearing in the Licensed Software, and 
    c. any Adaptations of the Licensed Software do not disable, modify or change the Licensed Software's requirement that an end-user accept the terms and conditions of the license agreement(s) contained in such Licensed Software before use and/or installation and 
    d. any Adaptations of the Licensed Software do not modify or change the terms and conditions of such license agreement(s). 

(4) Grant Back  -  Licensee hereby grants UGent a non-exclusive, royalty-free, fully paid-up, worldwide, perpetual license to: 
    a. Reproduce and prepare derivative works based on and distribute all or part of any Grant Back Software; and 
    b. make, have made, use, offer to sell, sell, license or import any products (including software) or services under any intellectual property rights owned or licensed by Licensee which relate to (1) all or part of any Grant Back Software or  (2) methods or concepts embodied in, or implemented through the execution of any Grant Back Software.
Licensee shall provide UGent with copies of Grant Back Software in source code form dirk.stroobandt@ugent.be. 

(5) Distributing and Receiving Adaptations  -  Licensee may provide an Adaptation to other people or entities only if:
    a. either such other people or entities have already downloaded the Licensed Software directly from UGent and have agreed to the same terms as this Agreement, and 
    b. the Adaptation is provided by Licensee for Non-Commercial Purposes, without any charge or fee, 
    c. the Adaptation is provided with a short summary of the difference between the Adaptation and the Licensed Software downloaded from UGent, 
    d. such other people or entities treat the Adaptation as Licensed Software under this Agreement with UGent, and 
    e. before Licensee sends such Adaptation to any other people or entities, Licensee first provides UGent with a copy of the Adaptation (in source code form) and the summary. 
Licensee shall treat as Licensed Software under this Agreement any Adaptation it may receive from another person or entity.

(6) No Other Rights  -  Licensee acknowledges that it obtains no ownership rights in the Licensed Software under the terms of this Agreement. All rights in the Licensed Software including but not limited to trade secrets, trademarks, service marks, patents, and copyrights are, shall be and will remain the property and ownership of UGent. All copies of the Licensed Software delivered to Licensee or made by Licensee remain the property of UGent. Except as expressly authorized under this Agreement, Licensee shall not use, copy, distribute, display or transfer the licensed software in any form.

(7) Third party rights  -  Licensee warrants that it has obtained lawful permission to use all hardware and software required in order to use the Licensed Software including but not limited to obtaining appropriate licenses to use and create software in the Java and Python program languages.

(8) Warranty Disclaimer  -  UGent has no obligation to support or maintain the Licensed Software and grants Licensee this right to use the Licensed Software "as is". Licensee, and anyone to whom Licensee provides the Licensed Software pursuant to this Agreement, assume total responsibility and risk for Licensee's use of the Licensed Software. UGent does not make, and expressly disclaims, any express or implied warranties, representations or endorsements of any kind whatsoever, including, without limitation, the implied warranties of merchantability or fitness for a particular purpose, and the warranties of title or non-infringement.

In no event shall UGent be liable for 
	(a) any incidental, consequential, or indirect damages (including, without limitation, damages for loss of profits, business interruption, loss of programs or information, and the like) arising out of the use of or inability to use the Licensed Software, even if UGent or any of its authorized representatives has been advised of the possibility of such damages, 
	(b) any claim attributable to errors, omissions, or other inaccuracies in the Licensed Software, or 
	(c) any claim by any third party. 
By way of example only, UGent does not warrant that the Licensed Software will be error-free. As used in this section, "UGent" includes its employees, directors, officers, agents, representatives, subcontractors, service providers and suppliers. 

(9) Sole Remedy  -  If for any reason the Software is unusable or does not perform as Licensee intended or expected, then Licensee's sole remedy shall be to either terminate this Agreement or to modify the Software to create an Adaptation which is usable or performs as intended or expected. This limitation on remedies shall apply even if Licensee cannot modify the Software to make the Software usable or perform as intended or expected. Because some states do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to Licensee. In the event applicable state or federal law does not allow the complete exclusion of any warranties as set forth in this Agreement, UGent's liability is limited to the greatest extent permitted by law.

(10) Communications  -  By downloading and installing the Licensed Software, Licensee agrees that UGent may send e-mail messages or communications relating to the Licensed Software to Licensee, its employees and representatives.

(11) Termination  -  This Agreement and the rights granted to Licensee shall terminate automatically if Licensee fails to comply with any of the terms and conditions of this Agreement. Upon termination, all licenses granted herein shall terminate and Licensee shall immediately destroy all copies of the Licensed Software. 

(12) Applicable Law  -  This Agreement shall be governed by and construed in accordance with the laws of the Belgium, without regard to its conflicts of law rules. The Commercial courts of Gent, Belgium are exclusively competent. 

(13) Assignment  -  Neither this Agreement nor any of Licensee's rights hereunder shall be assigned, sublicensed, or transferred (in insolvency proceedings, by mergers, acquisitions or otherwise) by Licensee without the written consent of UGent. Any assignment or other transfer which is inconsistent with the foregoing shall be null and void ab initio. UGent may assign all or a portion of its rights and obligations hereunder. 

Copyright (c) 2012, Ghent University - HES group
All rights reserved.
*/
package be.ugent.elis.recomp.mapping.utils;


import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

import net.sf.javabdd.BDD;
import be.ugent.elis.recomp.aig.AIG;
import be.ugent.elis.recomp.synthesis.BooleanFunction;
import be.ugent.elis.recomp.util.GlobalConstants;

public class Cone implements Comparable<Cone> {
	
	private final Node root;
	private Cone parent0, parent1;
	protected Collection<Node> regularLeaves;
	protected long signature;

	private ArrayList <Node> nodes;
	
	private BDD localFunction;
	private final BDDidMapping<Node> bddIdMapping;
	
	enum ConeType {LUT, TLUT, TCON, TLC, TRIVIAL, NONE, UNMAPPED}; 
	private ConeType type;
	
	private double depth;
	private double areaflow;
	private int area;
	private boolean hasParameterLeaves;

	private UniqueRegularLeafSubBDDIterator regularLeafSubBDDIterator;

	private BDD feasibilityFunction;
	

	public Cone(Node node, BDDidMapping<Node> bddIdMapping) {
		this(node, bddIdMapping, null, null);
	}
	
	public Cone(Node node, Collection<Node> regularLeaves, BDDidMapping<Node> bddIdMapping, Cone parent0, Cone parent1) {
		this.root = node;
		this.parent0 = parent0;
		this.parent1 = parent1;
		this.regularLeaves = regularLeaves;
		this.signature = 0;
		this.localFunction = null;
		this.bddIdMapping = bddIdMapping;
		this.type = ConeType.UNMAPPED;
		this.hasParameterLeaves = false;
		this.area = -1;
		this.areaflow = -1.;
		this.depth = -1.; 
	}
	
	public Cone(Node node, BDDidMapping<Node> bddIdMapping, Cone parent0, Cone parent1) {
		this(node, new HashSet<Node>(), bddIdMapping, parent0, parent1);
	}

	
	public void free() {
		setLocalFunction(null);
	}
	
	public void freeRec() {
		setLocalFunction(null);
		if(parent0!=null)
			parent0.freeRec();
		if(parent1!=null)
			parent1.freeRec();
	}
	
	public static Cone createCone(AIG<Node, Edge> aig, String root, String rleaves, String pLeaves) {
		Cone result = new Cone(aig.getNode(root), null);
		
		Scanner scan = new Scanner(rleaves);
		while (scan.hasNext()) {
			result.addRegularLeave(aig.getNode(scan.next()));
		}
		scan.close();

		scan = new Scanner(pLeaves);
		while (scan.hasNext()) {
			result.addParameterLeave(aig.getNode(scan.next()));
		}
		
		scan.close();
		return result;
	}
	
	public static Cone emptyCone(Node node, BDDidMapping<Node> bddIdMapping) {
		Cone result = new Cone(node, bddIdMapping);
		result.calculateSignature();
		return result;
	}

	public static Cone mergeCones(Node root, Cone cone0, Cone cone1, int maxConeSizeConsidered, int maxBddSizeConsidered) {
		if(root.getN0() != cone0.getRoot()) {
			Cone tmp = cone0;
			cone0 = cone1;
			cone1 = tmp;
		}
		if(GlobalConstants.assertFlag && root.getN0() != cone0.getRoot())
			throw new RuntimeException();
		if(GlobalConstants.assertFlag && root.getN1() != cone1.getRoot())
			throw new RuntimeException();
		
		if(Long.bitCount(cone0.signature | cone1.signature) > maxConeSizeConsidered)
			return null;
		
		int initial_size = (cone0.getRegularLeaves().size() + cone1.getRegularLeaves().size())*(4/3)+1;
		Collection<Node> regularLeaves = new HashSet<Node>(initial_size, (float) 1.0);
		regularLeaves.addAll(cone0.getRegularLeaves());
		regularLeaves.addAll(cone1.getRegularLeaves());
		
		if(regularLeaves.size() > maxConeSizeConsidered)
			return null;

		Cone result = new Cone(root, regularLeaves, cone0.bddIdMapping, cone0, cone1);
		
		result.setSignature(cone0.signature | cone1.signature);
		result.setHasParameterLeaves(cone0.hasParameterLeaves || cone1.hasParameterLeaves);
		
		//if(GlobalConstants.enableStatsFlag)
		//	Logger.getLogger().log(new ConeComputedStats(result));
	
		return result;
	}

	public static Cone trivialCone(Node node, BDDidMapping<Node> bddIdMapping) {
		Cone result = new Cone(node, bddIdMapping);
		result.type = ConeType.TRIVIAL;
		result.hasParameterLeaves = node.isParameter();
		if(!node.isParameter())
			result.addLeave(node);
		result.calculateSignature();

		if(node.isPrimaryInput()) {
			result.setArea(0);
			result.setAreaflow(0);
			result.setDepth(0);
		} else {
			result.setArea(Integer.MAX_VALUE);
			result.setAreaflow(Double.POSITIVE_INFINITY);
			result.setDepth(Double.POSITIVE_INFINITY);
		}
		return result;
	}
	
	public static Cone twoInputCone(Node node, BDDidMapping<Node> bddIdMapping) {
		Edge edge0 = node.getI0();
		Edge edge1 = node.getI1();
		Node node0 = edge0.getTail();
		Node node1 = edge1.getTail();
		
		Cone cone0 = Cone.trivialCone(node0, bddIdMapping);
		Cone cone1 = Cone.trivialCone(node1, bddIdMapping);
		Cone result = Cone.mergeCones(node, cone0, cone1, Integer.MAX_VALUE, Integer.MAX_VALUE);
		cone0.free();
		cone1.free();
		return result;
	}

	public static Cone outputCone(Node node, BDDidMapping<Node> bddIdMapping) {
		if(!node.isPrimaryOutput())
			throw new RuntimeException("Only call this function with primary output node");
		Cone cone = new Cone(node, bddIdMapping);
		Node tail = node.getI0().getTail();
		cone.addLeave(tail);
		cone.calculateSignature();
		cone.mapToNone();
		return cone;
	}
	
	public Cone expandLeafNode(Node node) {
		if(GlobalConstants.assertFlag && !hasRegularLeaf(node))
			throw new RuntimeException("Can only expand leaf node");
		if(GlobalConstants.assertFlag && !node.isGate())
			throw new RuntimeException("Can only expand AND gate");
		Cone res = new Cone(getRoot(), bddIdMapping);
		res.addLeaves(this);
		res.removeRegularLeave(node);
		if(!getNodesInToOut().contains(node.getN0()) && !node.getN0().isParameter())
			res.addLeave(node.getN0());
		if(!getNodesInToOut().contains(node.getN1()) && !node.getN1().isParameter())
			res.addLeave(node.getN1());
		return res;
	}
	
	private void setSignature(long signature) {
		this.signature = signature;
	}
	
	public long getSignature() {
		return signature;
	}

	public Node getRoot() {
		return root;
	}
	
	public Cone getParent0() {
		return parent0;
	}

	public Cone getParent1() {
		return parent1;
	}

	public void resetParents() {
		parent0 = null;
		parent1 = null;
	}

	private void setLocalFunction(BDD function) {
		if(this.localFunction != null)
			this.localFunction.free();
		this.localFunction = function;
	}
	
	public boolean isLocalFunctionDefined() {
		return localFunction != null;
	}
	
	public BDD getLocalFunction() {
		if(localFunction == null)
			localFunction = calculateLocalFunction();
		return localFunction;
	}
	
	public BDD getParamRestrictedLocalFunction() {
		if(GlobalConstants.feasibility_uses_activationfunction && getRoot().getOutputActivationFunction()!=null)
			return getLocalFunction().and(getRoot().getOutputActivationFunction())
				.orWith(getRoot().getOnParamFunction().id())
				.andWith(getRoot().getOffParamFunction().not());
		else
			return getLocalFunction().id();
	}

	private void setArea(int area) {
		this.area = area;
	}

	public int getArea() {
		if(GlobalConstants.assertFlag && area<0)
			throw new RuntimeException("Area has not been calculated");
		return area;
	}

	private void setDepth(double depth) {
		this.depth = depth;
	}

	public double getDepth() {
		if(GlobalConstants.assertFlag && depth<0)
			throw new RuntimeException("Depth has not been calculated");
		return depth;
	}

	private void setAreaflow(double areaflow) {
		this.areaflow = areaflow;
	}

	public double getAreaflow() {
		if(GlobalConstants.assertFlag && areaflow<0)
			throw new RuntimeException("Areaflow has not been calculated");
		return areaflow;
	}
	
	public int size() {
		return regularLeaves.size();
	}
	
	public void checkMapped() {
		if(GlobalConstants.assertFlag && type == ConeType.UNMAPPED)
			throw new RuntimeException("Cone is not mapped to specific primitive yet");
	}
	
	public ConeType getType() {
		return type;
	}
	
	public boolean isUnmapped() {
		return type == ConeType.UNMAPPED;
	}
	
	public void mapToNone() {
		this.type = ConeType.NONE;
	}
	
	public boolean isNone() {
		return type == ConeType.NONE;
	}
	
	public boolean isTrivial() {
//		return regularLeaves.size() == 1 
//				&& regularLeaves.contains(this.root);
		return type == ConeType.TRIVIAL;
	}
	
	public void mapToTrivial() {
		this.type = ConeType.TRIVIAL;
	}
	
	public boolean isLUT() {
		checkMapped();
		return this.type == ConeType.LUT;
	}
	
	public void mapToLUT() {
		this.type = ConeType.LUT;
	}
	
	public boolean isTLUT() {
		checkMapped();
		return this.type == ConeType.TLUT;
	}
	
	public void mapToTLUT() {
		this.type = ConeType.TLUT;
	}

	public boolean isTCON() {
		checkMapped();
		return this.type == ConeType.TCON;
	}
	
	public void mapToTCON() {
		this.type = ConeType.TCON;
	}

	public boolean isTLC() {
		checkMapped();
		return this.type == ConeType.TLC;
	}
	
	public void mapToTLC() {
		this.type = ConeType.TLC;
	}
	
	public boolean isTuneable() {
		checkMapped();
		return this.type == ConeType.TCON
				|| this.type == ConeType.TLUT
				|| this.type == ConeType.TLC;
	}
	
	public boolean usesLUTResource() {
		checkMapped();
		return this.type == ConeType.LUT
				|| this.type == ConeType.TLUT
				|| this.type == ConeType.TLC;
	}
	
	public boolean usesTLUTResource() {
		checkMapped();
		return this.type == ConeType.TLUT
				|| this.type == ConeType.TLC;
	}
	
	public boolean usesTCONResource() {
		checkMapped();
		return this.type == ConeType.TCON
				|| this.type == ConeType.TLC;
	}



	public Collection<Node> getParameterLeaves() {
		HashSet<Node> result = new HashSet<Node>();
		for (Node node: getNodesInToOut()) {
			if (node.getI0().getTail().isParameterInput()) {
				result.add(node.getI0().getTail());
			}
			if (node.getI1().getTail().isParameterInput()) {
				result.add(node.getI1().getTail());
			}
		}
		return result;
	}

	public ArrayList<Node> getParameterLeavesInFixedOrder() {
		ArrayList<Node> result = new ArrayList<Node>(getParameterLeaves());
		Collections.sort(result, new AlphanumNodeNameComparator());
		return result;
	}
	
	public Collection<Node> getRegularLeaves() {
		return regularLeaves;
	}

	public ArrayList<Node> getRegularLeavesInFixedOrder() {
		ArrayList<Node> result = new ArrayList<Node>(getRegularLeaves());
		Collections.sort(result, new AlphanumNodeNameComparator());
		return result;
	}
	
	public Collection<Node> getAllLeaves() {
		ArrayList<Node> result = new ArrayList<Node>(getParameterLeaves());
		result.addAll(getRegularLeaves());
		return result;
	}
	
	public ArrayList<Node> getAllLeavesInFixedOrder() {
		ArrayList<Node> result = new ArrayList<Node>(getParameterLeavesInFixedOrder());
		result.addAll(getRegularLeavesInFixedOrder());
		return result;
	}

	private void addLeave(Node node) {
		if (node.isParameter() && node.isInput()) {
			addParameterLeave(node);
		} else {
			addRegularLeave(node);
		}
	}

	private void addRegularLeave(Node node) {
		nodes = null;

		regularLeaves.add(node);
	}

	private void addParameterLeave(Node node) {
//		nodes = null;
//		hashCode = 0;

//		parameterLeaves.add(node);
	}
	
	private void removeRegularLeave(Node node) {
		nodes = null;

		regularLeaves.remove(node);
	}

	private void addLeaves(Cone cone0) {
		nodes = null;

		this.regularLeaves.addAll(cone0.regularLeaves);
//		this.parameterLeaves.addAll(cone0.parameterLeaves);
	}
	
	public boolean hasRegularLeaf(Node node) {
		return this.regularLeaves.contains(node);
	}
	
	private void setHasParameterLeaves(boolean val) {
		hasParameterLeaves = val;
	}
	
	public boolean hasParameterLeaves() {
//		return getParameterLeaves().size() != 0;
		//return hasParameterLeavesRec(root);
		return hasParameterLeaves;
	}
	
	@SuppressWarnings("unused")
	private boolean hasParameterLeavesRec(Node node) {
		if(node.isParameter()) return true;
		if(hasRegularLeaf(node)) return false;
		return hasParameterLeavesRec(node.getI0().getTail())
				|| hasParameterLeavesRec(node.getI1().getTail());
	}

	
	protected void calculateSignature() {
		signature = 0;
		for (Node n: regularLeaves) {
			signature |= (1l << (n.hashCode() % 64));
		}
	}
	
	
	public boolean isLUTfeasible(int K) {
		return size() <= K && !hasParameterLeaves();
	}
	
	public boolean isTLUTfeasible(int K) {
		return size() <= K;
	}
	
	@SuppressWarnings("unused")
	private static int countNonZero(int[] array) {
		int count = 0;
		for(int e : array)
			count += e!=0 ? 1 : 0;
		return count;
	}
	
	private static int countBDDVars(BDD bdd) {
		return bdd.supportSize();
//		BDD support = bdd.support();
//		int res = support.nodeCount();
//		support.free();
////		if(res != countNonZero(bdd.varProfile()))
////			throw new RuntimeException("invalid support"); 
//		return res;
	}
	
	public boolean isNoneFeasible() {
		return isTLCfeasible(0);
	}
	
	public boolean isTCONfeasible() {
		return isTLCfeasible(1);
	}
	
	public boolean isTLCfeasible(int K) {
		if(!hasParameterLeaves())
			return isLUTfeasible(K);
		regularLeafSubBDDIterator.reset();
		while(regularLeafSubBDDIterator.hasNext()) {
			if(countBDDVars(regularLeafSubBDDIterator.next()) > K)
				return false;
		}
		return true;
	}
	
	public void initFeasibilityCalculation(boolean bddsUsed) {
		if(bddsUsed) {
			feasibilityFunction = getParamRestrictedLocalFunction();
			regularLeafSubBDDIterator = new UniqueRegularLeafSubBDDIterator(feasibilityFunction, this.bddIdMapping);
		}
	}
	
	public void finishFeasibilityCalculation() {
		if(regularLeafSubBDDIterator != null) {
			regularLeafSubBDDIterator.free();
			regularLeafSubBDDIterator = null;
		}
		if(feasibilityFunction != null) {
			feasibilityFunction.free();
			feasibilityFunction = null;
		}
	}


	public ArrayList<Node> getNodesInToOut() {
		if (nodes == null) {
			ArrayList<Node> result = new ArrayList<Node>();
			Set<Node> visited = new HashSet<Node>();
			nodes = getNodesRec(result,visited, root);
		}
		return nodes;
	}

	private ArrayList<Node> getNodesRec(ArrayList<Node> result, Set<Node> visited, Node node) {
		
		if (!regularLeaves.contains(node) && !node.isParameterInput() && !visited.contains(node)) {
			
			visited.add(node);
//			result.add(node);
			

			switch (node.getType()) {
			case AND:
				getNodesRec(result, visited, node.getI0().getTail());
				getNodesRec(result, visited, node.getI1().getTail());
				break;
			default:
				break;
			}
			
			result.add(node);

		}
		return result;
	}
	
	public BooleanFunction<Node> getBooleanFunction(boolean paramRestricted) {
		BDD bdd;
		if(paramRestricted)
			bdd = getParamRestrictedLocalFunction();
		else
			bdd = getLocalFunction().id();
		
		return new BooleanFunction<Node>(bddIdMapping, bdd);
	}

	private BDD calculateFunctionOfMergedCones() {
		if(parent0 == null || parent1 == null)
			return calculateFunctionOfCone();
		BDD function0 = parent0.getLocalFunction().id();
		BDD function1 = parent1.getLocalFunction().id();
		
		if(root.getI0().isInverted()) {
			BDD nfunction0 = function0.not();
			function0.free();
			function0 = nfunction0;
		}
		if(root.getI1().isInverted()) {
			BDD nfunction1 = function1.not();
			function1.free();
			function1 = nfunction1;
		}
		
		BDD result = function0.andWith(function1);
		return result;
	}

	private BDD calculateFunctionOfCone() {
		HashMap<Node, BDD> map = new HashMap<Node, BDD>();
		for(Node n : getAllLeaves())
			map.put(n, n.getBDD(bddIdMapping));
		BDD bdd = calculateFunctionOfConeRec(getRoot(), map).id();
		for(BDD b : map.values())
			b.free();
		return bdd;
	}
	
	private BDD calculateFunctionOfConeRec(Node n, HashMap<Node, BDD> map) {
		if(map.containsKey(n))
			return map.get(n);
		if(!n.isGate())
			throw new RuntimeException("Expecting an AND gate");
		BDD bdd0 = calculateFunctionOfConeRec(n.getN0(), map);
		BDD bdd0_ci = n.getI0().isInverted() ? bdd0.not() : bdd0.id();
		BDD bdd1 = calculateFunctionOfConeRec(n.getN1(), map);
		BDD bdd1_ci = n.getI1().isInverted() ? bdd1.not() : bdd1.id();
		BDD bdd = bdd0_ci.and(bdd1_ci);
		bdd0_ci.free();
		bdd1_ci.free();
		map.put(n, bdd);
		return bdd;
	}

	private BDD calculateLocalFunction() {
		if(root.isPrimaryOutput()) {
			BDD tmp = root.getI0().getTail().getBDD(bddIdMapping);
			if(root.getI0().isInverted()) {
				BDD ntmp = tmp.not();
				tmp.free();
				tmp = ntmp;
			}
			return tmp;
		} else if(root.isPrimaryInput() || isTrivial()) {
			return root.getBDD(bddIdMapping);
		} else if(root.isGate()) {
			return calculateFunctionOfMergedCones();
		} else
			throw new RuntimeException();
	}

	public boolean dominates(Cone cone) {
		long test = this.getSignature() & (~ cone.getSignature());
		if (test==0)
			return cone.regularLeaves.containsAll(this.regularLeaves);
		else
			return false;
	}
	
	public int getAreaCostOfCone() {
		if (usesLUTResource())
			return 1;
		else 
			return 0;
	}
	
	public int getDepthCostOfCone() {
		if (usesLUTResource())
			return 1;
		else 
			return 0;
	}

//	public int numParameters() {
//		return parameterLeaves.size();
//	}

	private double getMaximumInputDepth() {
		double result=0;
		
		for (Node n: regularLeaves) {
			if (n.getDepth()>result)
				result = n.getDepth();
		}
		return result;
	}
	
	private void calculateAreaflow() {
		if (getRoot().isPrimaryInput()) {
			setAreaflow(0.);
			
		} else if (getRoot().isPrimaryOutput()) {
			setAreaflow(getRoot().getI0().getAreaflow());
			
		} else if (isTrivial()) {
			// Trivial cones should never be chosen they are only used
			// for cone enumeration.
			setAreaflow(Double.POSITIVE_INFINITY);
			
		} else {
			double areaflow = 0;
			for (Node n: getRegularLeaves())
				areaflow += n.getAreaflow()/n.getEstimatedFanout();

			setAreaflow(areaflow + getAreaCostOfCone());
		}
	}
	
	public void calculateDepth() {
		if (getRoot().isPrimaryInput()) {
			setDepth(0.);
		
		} else if (getRoot().isPrimaryOutput()) {
			setDepth(getRoot().getI0().getDepth());
			
		} else if (isTrivial()) {
			// Trivial cones should never be chosen they are only used
			// for cone enumeration.
			setDepth(Double.POSITIVE_INFINITY);

		} else {
			setDepth(getMaximumInputDepth() + getDepthCostOfCone());
		}
	}

	public int dereferenceMFFC() {
		if(root.isPrimaryInput())
			return 0;
		int a = getAreaCostOfCone();
		for (Node n : getRegularLeaves()) {
			int r = n.decrementReferences();
			if (r == 0) {
				a += n.dereferenceMFFC();
			}
		}
		return a;
	}

	public int referenceMFFC() {
		if(root.isPrimaryInput())
			return 0;
		int a = getAreaCostOfCone();
		for (Node n : getRegularLeaves()) {
			int r = n.incrementReferences();
			if (r == 1) {
				a += n.referenceMFFC();
			}
		}
		return a;
	}

	/* exact area calculation algorithm:
	 * calculating the number of LUTs used in the fanin cone of a node/cone, 
	 * that are NOT used in the fanin of any other currently "visible" (selected) node
	 * 
	 * Start by calculating the number of references/uses of all nodes for the current mapping
	 * In the cone ranking stage: if the current node is part of the mapping, dereference its fanin
	 * for every feasible cone, reference the nodes in its fanin and count those that are not used
	 * by any other node
	 */	
	private void calculateArea() {
		if(isTrivial())
			return;
		int a = referenceMFFC();
		int a2 = dereferenceMFFC();
		if(GlobalConstants.assertFlag && a != a2)
			throw new RuntimeException();
		setArea(a);
	}
	
	public void markConeAndLeaves(boolean marked) {
		for(Node n : getRegularLeaves())
			n.setMarked(marked);
		getRoot().setMarkedRecursive(marked);
	}
	
	public int compareTo(Cone o) {
		if (this.root == o.root) {
			if (this.regularLeaves.equals(o.regularLeaves)) {
//				if (this.parameterLeaves.equals(o.parameterLeaves)) {
					return 0;
//				}
			}
		}
		return -1;
	}

	@Override
	public boolean equals(Object obj) {
		Cone o = (Cone) obj;
		if (this.root == o.root) {
			if (this.regularLeaves.equals(o.regularLeaves)) {
//				if (this.parameterLeaves.equals(o.parameterLeaves)) {
					return true;
//				}
			}
		}
		return false;
	}


	@Override
	public int hashCode() {
		return Long.valueOf(getSignature()).hashCode();
//		if(hashCode == 0) {
//			hashCode = root.hashCode();
//			for (Node n : regularLeaves)
//				hashCode ^= n.hashCode();
////			for (Node n : parameterLeaves)
////				hashCode ^= n.hashCode();	
//		}
//		return hashCode;
	}

	@Override
	public String toString() {
		String result = new String();
		result  = "(" + this.root.getName() + ",";
		
		result += "{";
		
		ArrayList<String> nodesNames = new ArrayList<String>();
		for (Node n:regularLeaves) {
			nodesNames.add(n.getName());
		}
		Collections.sort(nodesNames);
		
		for (int i=0; i < nodesNames.size(); i++) {
			if (i !=0)
				result += ",";
			result += nodesNames.get(i);
		}
//		result += "},";
//
//		result += "{";
//
//		nodesNames = new Vector<String>();
//		for (Node n:parameterLeaves) {
//			nodesNames.add(n.getName());
//		}
//		Collections.sort(nodesNames);
//		for (int i=0; i < nodesNames.size(); i++) {
//			if (i !=0)
//				result += ",";
//			result += nodesNames.get(i);
//		}
		result += "},";
		result += getRoot().isParameter() + ",";
		result += getType();
		result += ")";

		return result;
	}

	public void reduceMemoryUsage() {
		regularLeaves = new ArrayList<Node>(regularLeaves);
		((ArrayList<Node>)regularLeaves).trimToSize();
	}

	public boolean mapCone(int K, boolean tcon_mapping_flag, boolean tlc_mapping_flag) {
		if(isUnmapped()) {
			initFeasibilityCalculation(tcon_mapping_flag || tlc_mapping_flag);
			if(tcon_mapping_flag && isTCONfeasible()) {
				mapToTCON();
			} else if(isTLUTfeasible(K)) {
				if(isLUTfeasible(K))
					mapToLUT();
				else
					mapToTLUT();
			} else if(tlc_mapping_flag && isTLCfeasible(K)) {
				mapToTLC();
			} else {// infeasible
				finishFeasibilityCalculation();
				return false;
			}
			finishFeasibilityCalculation();
		}
		return true;
	}
	
	public void calculateConeProperties() {
		calculateConeProperties(true);
	}
	
	public void calculateConeProperties(boolean area_calculation_flag) {
		calculateDepth();
		if(area_calculation_flag)
			calculateArea();
		calculateAreaflow();
	}
}
