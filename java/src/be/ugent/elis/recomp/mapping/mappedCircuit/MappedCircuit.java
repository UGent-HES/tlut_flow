/*
SOFTWARE LICENSE AGREEMENT

This software license agreement (hereinafter referred to as the "Agreement") provides the terms and conditions under which Universiteit Gent - Ghent University (hereinafter referred to as "UGent") is willing to grant you (being the person or entity installing and using the Licensed Software for Non-Commercial Purposes, hereinafter referred to as the "Licensee")  a non-exclusive, limited right to use the Licensed Software under UGent Copyright.

By downloading the Licensed Software, or installing Licensed Software, or using Licensed Software, or clicking on the "accept" button under this Agreement, Licensee agrees to accept the terms and conditions of this Agreement and agrees to be bound by this Agreement. If Licensee does not agree with any of the terms or conditions of this Agreement, he should not download or install or use the Licensed Software. 

(1) Licensee warrants and represents that the person accepting this Agreement on behalf of Licensee is its legally authorized representative and is duly authorized to accept agreements of this type on behalf of Licensee and obligate Licensee to the terms and conditions herein. Any breach of this warranty and representation is a material breach of this Agreement and, in such event, this Agreement and the rights granted to Licensee shall terminate automatically. 

(2) Definitions  -  For the purposes of this Agreement, the following terms shall have the following meanings:
a) "Software":  refers to the computer software supplied with this Agreement named "tlut flow" and provided in Python and Java code form. 
b) "Licensed Software":  refers to the Software, and any other computer software and documentation, if any, supplied with this Agreement. 
c) "Adaptation":  refers to any work based on the Licensed Software, including: 
    1) any work which incorporates all or part of the Licensed Software, 
    2) any work which includes modifications to the Software, including but not limited to bug fixes, 
    3) any work which would be regarded as a derivative work of the Software under the Belgian Copyright Law, and 
    4) any work which is otherwise covered by any of UGent's intellectual property rights in the Licensed Software. 
d) "Grant Back Software":  refers to any
        1) modification of the objects distributed as the Software, including but not limited to the addition, deletion, and modification of verbs and properties on the objects, 
        2) creation of children to the objects distributed as the Software. 
e) "Copyright Holder": refers to Universiteit Gent - Ghent University, public institution with legal personality, having its administrative offices in Belgium, B-9000 Gent, Sint-Pietersnieuwstraat 25 (herein also referred to as "UGent")
f) "Non-Commercial Purpose":  refers to use of the Licensed Software solely for the purpose of education or research. "Non-Commercial Purpose" excludes, without limitation, any use of the Software as part of or in connection with a product (including software) or service which is sold, offered for sale, licensed, leased, loaned or rented.

(3) Adaptations  -  Licensee may create Adaptations of the Licensed Software only if 
    a. Licensee treats the Adaptations as Licensed Software under this Agreement, and 
    b. the Adaptations include all copyright notices appearing in the Licensed Software, and 
    c. any Adaptations of the Licensed Software do not disable, modify or change the Licensed Software's requirement that an end-user accept the terms and conditions of the license agreement(s) contained in such Licensed Software before use and/or installation and 
    d. any Adaptations of the Licensed Software do not modify or change the terms and conditions of such license agreement(s). 

(4) Grant Back  -  Licensee hereby grants UGent a non-exclusive, royalty-free, fully paid-up, worldwide, perpetual license to: 
    a. Reproduce and prepare derivative works based on and distribute all or part of any Grant Back Software; and 
    b. make, have made, use, offer to sell, sell, license or import any products (including software) or services under any intellectual property rights owned or licensed by Licensee which relate to (1) all or part of any Grant Back Software or  (2) methods or concepts embodied in, or implemented through the execution of any Grant Back Software.
Licensee shall provide UGent with copies of Grant Back Software in source code form dirk.stroobandt@ugent.be. 

(5) Distributing and Receiving Adaptations  -  Licensee may provide an Adaptation to other people or entities only if:
    a. either such other people or entities have already downloaded the Licensed Software directly from UGent and have agreed to the same terms as this Agreement, and 
    b. the Adaptation is provided by Licensee for Non-Commercial Purposes, without any charge or fee, 
    c. the Adaptation is provided with a short summary of the difference between the Adaptation and the Licensed Software downloaded from UGent, 
    d. such other people or entities treat the Adaptation as Licensed Software under this Agreement with UGent, and 
    e. before Licensee sends such Adaptation to any other people or entities, Licensee first provides UGent with a copy of the Adaptation (in source code form) and the summary. 
Licensee shall treat as Licensed Software under this Agreement any Adaptation it may receive from another person or entity.

(6) No Other Rights  -  Licensee acknowledges that it obtains no ownership rights in the Licensed Software under the terms of this Agreement. All rights in the Licensed Software including but not limited to trade secrets, trademarks, service marks, patents, and copyrights are, shall be and will remain the property and ownership of UGent. All copies of the Licensed Software delivered to Licensee or made by Licensee remain the property of UGent. Except as expressly authorized under this Agreement, Licensee shall not use, copy, distribute, display or transfer the licensed software in any form.

(7) Third party rights  -  Licensee warrants that it has obtained lawful permission to use all hardware and software required in order to use the Licensed Software including but not limited to obtaining appropriate licenses to use and create software in the Java and Python program languages.

(8) Warranty Disclaimer  -  UGent has no obligation to support or maintain the Licensed Software and grants Licensee this right to use the Licensed Software "as is". Licensee, and anyone to whom Licensee provides the Licensed Software pursuant to this Agreement, assume total responsibility and risk for Licensee's use of the Licensed Software. UGent does not make, and expressly disclaims, any express or implied warranties, representations or endorsements of any kind whatsoever, including, without limitation, the implied warranties of merchantability or fitness for a particular purpose, and the warranties of title or non-infringement.

In no event shall UGent be liable for 
	(a) any incidental, consequential, or indirect damages (including, without limitation, damages for loss of profits, business interruption, loss of programs or information, and the like) arising out of the use of or inability to use the Licensed Software, even if UGent or any of its authorized representatives has been advised of the possibility of such damages, 
	(b) any claim attributable to errors, omissions, or other inaccuracies in the Licensed Software, or 
	(c) any claim by any third party. 
By way of example only, UGent does not warrant that the Licensed Software will be error-free. As used in this section, "UGent" includes its employees, directors, officers, agents, representatives, subcontractors, service providers and suppliers. 

(9) Sole Remedy  -  If for any reason the Software is unusable or does not perform as Licensee intended or expected, then Licensee's sole remedy shall be to either terminate this Agreement or to modify the Software to create an Adaptation which is usable or performs as intended or expected. This limitation on remedies shall apply even if Licensee cannot modify the Software to make the Software usable or perform as intended or expected. Because some states do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to Licensee. In the event applicable state or federal law does not allow the complete exclusion of any warranties as set forth in this Agreement, UGent's liability is limited to the greatest extent permitted by law.

(10) Communications  -  By downloading and installing the Licensed Software, Licensee agrees that UGent may send e-mail messages or communications relating to the Licensed Software to Licensee, its employees and representatives.

(11) Termination  -  This Agreement and the rights granted to Licensee shall terminate automatically if Licensee fails to comply with any of the terms and conditions of this Agreement. Upon termination, all licenses granted herein shall terminate and Licensee shall immediately destroy all copies of the Licensed Software. 

(12) Applicable Law  -  This Agreement shall be governed by and construed in accordance with the laws of the Belgium, without regard to its conflicts of law rules. The Commercial courts of Gent, Belgium are exclusively competent. 

(13) Assignment  -  Neither this Agreement nor any of Licensee's rights hereunder shall be assigned, sublicensed, or transferred (in insolvency proceedings, by mergers, acquisitions or otherwise) by Licensee without the written consent of UGent. Any assignment or other transfer which is inconsistent with the foregoing shall be null and void ab initio. UGent may assign all or a portion of its rights and obligations hereunder. 

Copyright (c) 2012, Ghent University - HES group
All rights reserved.
 */

package be.ugent.elis.recomp.mapping.mappedCircuit;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import net.sf.javabdd.BDD;
import net.sf.javabdd.BDDFactory;
import net.sf.javabdd.BDDPairing;
import be.ugent.elis.recomp.aig.AIG;
import be.ugent.elis.recomp.aig.NodeType;
import be.ugent.elis.recomp.mapping.outputgeneration.BlifGenerator;
import be.ugent.elis.recomp.mapping.outputgeneration.VhdlGenerator;
import be.ugent.elis.recomp.mapping.outputgeneration.Virtex2ProVhdlGenerator;
import be.ugent.elis.recomp.mapping.outputgeneration.Virtex5VhdlGenerator;
import be.ugent.elis.recomp.mapping.utils.AlphanumMappedNodeNameComparator;
import be.ugent.elis.recomp.mapping.utils.BDDPair;
import be.ugent.elis.recomp.mapping.utils.BDDidMapping;
import be.ugent.elis.recomp.mapping.utils.Edge;
import be.ugent.elis.recomp.mapping.utils.MappingAIG;
import be.ugent.elis.recomp.mapping.utils.Node;
import be.ugent.elis.recomp.mapping.utils.PolarisedNode;
import be.ugent.elis.recomp.mapping.utils.RegularLeafSubBDDIterator;
import be.ugent.elis.recomp.synthesis.BDDFactorySingleton;
import be.ugent.elis.recomp.synthesis.BooleanFunction;
import be.ugent.elis.recomp.synthesis.TruthAssignment;
import be.ugent.elis.recomp.synthesis.TruthAssignmentIterator;
import be.ugent.elis.recomp.util.IsParameterInterface;

public class MappedCircuit {

	private String name;

	private MappedConst const0;
	private MappedConst const1;
	private ArrayList<MappedInput> inputs;
	private ArrayList<MappedILatch> ilatches;
	private ArrayList<MappedOLatch> olatches;
	private ArrayList<MappedOutput> outputs;
	private ArrayList<MappedGate> gates;

	private int K;

	public MappedCircuit(String name, int K) {
		this.name = name;
		this.K = K;
		this.const0 = new MappedConst(this, "const0", "0");
		this.const1 = new MappedConst(this, "const1", "1");
		this.inputs = new ArrayList<MappedInput>();
		this.ilatches = new ArrayList<MappedILatch>();
		this.olatches = new ArrayList<MappedOLatch>();
		this.outputs = new ArrayList<MappedOutput>();
		this.gates = new ArrayList<MappedGate>();
	}
	
	public void free() {
		for (MappedNode node : getAllNodes())
			node.free();
		this.inputs.clear();
		this.ilatches.clear();
		this.olatches.clear();
		this.outputs.clear();
		this.gates.clear();
	}

	public String getName() {
		return name;
	}

	public MappedConst getConst0() {
		return const0;
	}

	public MappedConst getConst1() {
		return const1;
	}

	public ArrayList<MappedInput> getInputs() {
		return inputs;
	}

	public ArrayList<MappedPrimaryInput> getPrimaryInputs() {
		ArrayList<MappedPrimaryInput> all = new ArrayList<MappedPrimaryInput>();
		all.addAll(getInputs());
		all.addAll(getOLatches());
		return all;
	}

	public ArrayList<MappedILatch> getILatches() {
		return ilatches;
	}

	public ArrayList<MappedOLatch> getOLatches() {
		return olatches;
	}

	public ArrayList<MappedOutput> getOutputs() {
		return outputs;
	}

	public ArrayList<MappedPrimaryOutput> getPrimaryOutputs() {
		ArrayList<MappedPrimaryOutput> all = new ArrayList<MappedPrimaryOutput>();
		all.addAll(getOutputs());
		all.addAll(getILatches());
		return all;
	}

	public ArrayList<MappedGate> getGates() {
		return gates;
	}

	public ArrayList<MappedNode> getAllNodes() {
		ArrayList<MappedNode> all = new ArrayList<MappedNode>();
		all.addAll(getOutputs());
		all.addAll(getILatches());
		all.addAll(getOLatches());
		all.addAll(getInputs());
		all.addAll(getGates());
		all.add(getConst0());
		all.add(getConst1());
		return all;
	}

	public MappedInput addInput(String name, boolean parameter) {
		MappedInput n = new MappedInput(this, name, parameter);
		inputs.add(n);
		return n;
	}

	public MappedOutput addOutput(String name) {
		MappedOutput n = new MappedOutput(this, name);
		outputs.add(n);
		return n;
	}

	public MappedLatchPair addLatch(String name) {
		MappedILatch in = new MappedILatch(this, name);
		MappedOLatch on = new MappedOLatch(this, name, in);
		olatches.add(on);
		ilatches.add(in);
		return new MappedLatchPair(in, on);
	}

	public MappedGate addGate(String name,
			BooleanFunction<MappedNode> function, String mapped_type) {
		MappedGate n = new MappedGate(this, name, function, mapped_type);
		gates.add(n);
		return n;
	}

	public MappedParameterisedGate addParameterisedGate(String name,
			ArrayList<MappedNode> inputs, ArrayList<MappedNode> configurations,
			String mapped_type) {
		MappedParameterisedGate n = new MappedParameterisedGate(this, name,
				inputs, configurations, mapped_type);
		gates.add(n);
		return n;
	}

	public MappedParameterisedConfigurationGate addParameterisedConfigurationGate(
			String name, BooleanFunction<MappedNode> function) {
		MappedParameterisedConfigurationGate n = new MappedParameterisedConfigurationGate(
				this, name, function);
		gates.add(n);
		return n;
	}

	public MappedParameterisedMux addParameterisedMux(String name,
			ArrayList<MappedNode> inputs, ArrayList<MappedNode> configurations) {
		MappedParameterisedMux n = new MappedParameterisedMux(this, name,
				inputs, configurations);
		gates.add(n);
		return n;
	}

	public ArrayList<MappedGate> getGatesInTopologicalOrderInToOut() {
		ArrayList<MappedGate> list = new ArrayList<MappedGate>();
		HashSet<MappedNode> visited = new HashSet<MappedNode>();

		for (MappedNode out : getPrimaryOutputs()) {
			inToOut_rec(out, list, visited);
		}

		return list;
	}

	private ArrayList<MappedGate> inToOut_rec(MappedNode node,
			ArrayList<MappedGate> list, HashSet<MappedNode> visited) {
		if (!visited.contains(node)) {
			visited.add(node);
			for (MappedNode source : node.getSources()) {
				inToOut_rec(source, list, visited);
			}
			if (node instanceof MappedGate)
				list.add((MappedGate) node);
		}
		return list;
	}

	public void printBlif(PrintStream stream) {
		BlifGenerator blifGenerator = new BlifGenerator();
		
		stream.print(blifGenerator.getModelDefinitionString(this.name));

		// Inputs
		stream.print(blifGenerator.getInputDefinitionString(MappedNode.getBlifIdentifiers(getInputs())));

		// Outputs
		stream.print(blifGenerator.getOutputDefinitionString(MappedNode.getBlifIdentifiers(getOutputs())));
		stream.println();

		// Const
		//if(getConst0().hasFanout())
			stream.println(getConst0().getBlifString(blifGenerator));
		//if(getConst1().hasFanout()) {
			stream.println(getConst1().getBlifString(blifGenerator));
		stream.println();

		// Latches
		for (MappedOLatch latch : getOLatches()) {
			stream.print(latch.getBlifString(blifGenerator));
		}
		stream.println();
		stream.println();

		// Outputs
		// TODO: remove?
		for (MappedOutput output : getOutputs()) {
			String s = output.getBlifString(blifGenerator);
			if(s != null)
				stream.println(s);
		}
		stream.println();

		// LUTs
		for (MappedGate gate : getGates()) {
			stream.println(gate.getBlifString(blifGenerator));
		}

		stream.print(blifGenerator.getFooterString());
		stream.flush();
	}

	public void printLutStructureVhdl(String inVhdFile, PrintStream stream,
			int K) throws IOException {
		VhdlGenerator vhdlGenerator;
		if (K == 4)
			vhdlGenerator = new Virtex2ProVhdlGenerator();
		else if (K == 6)
			vhdlGenerator = new Virtex5VhdlGenerator();
		else
			throw new RuntimeException("Unsupported LUT size: " + K);

		printVhdlHeader(stream, inVhdFile, vhdlGenerator);

		stream.println("begin");

		// Outputs
		for (MappedOutput out : getOutputs()) {
			stream.print(out.getVhdlString(vhdlGenerator));
		}
		stream.println();

		// Latches
		for (MappedOLatch latch : getOLatches()) {
			stream.print(latch.getVhdlString(vhdlGenerator));
		}
		stream.println();

		// LUTs
		for (MappedGate gate : getGates()) {
			stream.print(gate.getVhdlString(vhdlGenerator));
		}

		stream.println("end;");
		stream.flush();
	}

	private void printVhdlHeader(PrintStream stream, String inVhdFile,
			VhdlGenerator vhdlGenerator) throws IOException {
		// Read header old vhdl file as a String
		BufferedReader vhdlFileReader = new BufferedReader(new FileReader(
				new File(inVhdFile)));
		String vhdlFileLine = vhdlFileReader.readLine();
		String header = "--WARNING: Don't edit. Automatically regenerated file (TLUT flow)\n";
		while (vhdlFileLine.toLowerCase().indexOf("architecture") == -1) {
			header = header + vhdlFileLine + '\n';
			vhdlFileLine = vhdlFileReader.readLine();
		}
		vhdlFileReader.close();

		String[] headerArray;

		// Insert unisim library declaration if necessary
		headerArray = header.split("entity",
				java.util.regex.Pattern.CASE_INSENSITIVE);
		String libraryString = "-- synopsys translate_off\nlibrary UNISIM;\nuse unisim.Vcomponents.all;\n-- synopsys translate_on\n";
		if (header.indexOf("library UNISIM;") == -1)
			header = headerArray[0] + libraryString + "\nentity"
					+ headerArray[1];

		stream.println(header.trim());

		stream.println("\n" + vhdlFileLine);

		// Add component definitions
		vhdlGenerator.printComponentDefinitions(stream);

		// Add constraints
		vhdlGenerator.printConstraints(stream);

		// Add declaration of signals and init attributes
		stream.println("attribute S : string;");
		stream.println();

		// LUTs
		for (MappedGate gate : getGates()) {
			stream.print(gate.getVhdlHeaderString(vhdlGenerator));
			stream.println();
		}

		// Latches
		for (MappedOLatch latch : getOLatches()) {
			stream.println(latch.getVhdlHeaderString(vhdlGenerator));
			stream.println();
		}
	}

	public void printTLUTNames(PrintStream stream) {
		ArrayList<MappedNode> gates = new ArrayList<MappedNode>(getGates());
		Collections.sort(gates, new AlphanumMappedNodeNameComparator());
		for (MappedGate gate : getGates()) {
			if (gate.isTLUT())
				stream.println(gate.getVhdlIdentifier());
		}
		stream.flush();
	}

	/**
	 * Construct two mapped circuits from another mapped circuit. One circuit
	 * representing the lutstructure of the input circuit and one circuit
	 * representing the configuration of the parameterised primitives.
	 */
	public ParameterisedMappedCircuitPair constructParameterisedMappedCircuit() {
		MappedCircuit circuit = new MappedCircuit(getName(), K);
		MappedCircuit configurationCircuit = new MappedCircuit(getName()
				+ "_parconfig", -1);

		HashMap<MappedNode, MappedNode> mapping = new HashMap<MappedNode, MappedNode>();
		HashMap<MappedPrimaryOutput, MappedPrimaryOutput> outputMapping = new HashMap<MappedPrimaryOutput, MappedPrimaryOutput>();

		// Copy inputs, latches, outputs
		mapping.put(getConst0(), circuit.getConst0());
		mapping.put(getConst1(), circuit.getConst1());
		for (MappedInput in : getInputs()) {
			// Only copy regularInputs
			if (in.isParameter()) {
				MappedInput mappedN = configurationCircuit.addInput(
						in.getName(), in.isParameter());
				// !!!
				mapping.put(in, mappedN);
			} else {
				MappedInput mappedN = circuit.addInput(in.getName(),
						in.isParameter());
				mapping.put(in, mappedN);
			}
		}
		for (MappedOutput out : getOutputs()) {
			MappedOutput mappedN = circuit.addOutput(out.getName());
			outputMapping.put(out, mappedN);
		}
		for (MappedOLatch olatch : getOLatches()) {
			MappedLatchPair mappedNpair = circuit.addLatch(olatch.getName());
			mapping.put(olatch, mappedNpair.getOLatch());
			outputMapping.put(olatch.getILatch(), mappedNpair.getILatch());
		}

		// Separate configuration from LUT
		for (MappedGate gate : getGatesInTopologicalOrderInToOut()) {
			MappedGate mappedN;
			BDDFactory factory = BDDFactorySingleton.get();

			if (gate.getMappedType().equals("TMUX")) {
				BooleanFunction<MappedNode> function = gate.getFunction()
						.translate(mapping);

				BDDidMapping<MappedNode> bddIdMapping = function
						.getBDDidMapping();

				ArrayList<MappedNode> regularInputs = new ArrayList<MappedNode>();
				for (MappedNode node : function.getInputVariables())
					if (!node.isParameterInput())
						regularInputs.add(node);

				// Initialise the configuration functions of the TMUX
				ArrayList<BDD> tconConfigurations = new ArrayList<BDD>();
				for (int i = 0; i < regularInputs.size(); i++)
					tconConfigurations.add(factory.zero());

				// Warning: this is a bit dangerous. RegularLeafSubBDDIterator
				// requires that all parameters have a lower id than
				// non-parameters. This may not be the case if the local
				// function of a mappedgate has been constructed in some way.
				// This is fine if the bddidmapping still corresponds to the one
				// used in the MappingAIG.
				verifyBDDParamVarMapping(function);
				RegularLeafSubBDDIterator regularLeafSubBDDIterator = new RegularLeafSubBDDIterator(
						function.getBDD(), function.getBDDidMapping());
				while (regularLeafSubBDDIterator.hasNext()) {
					BDDPair pair = regularLeafSubBDDIterator.next();
					BDD param_condition = pair.first;
					BDD subBDD = pair.second;
					if (subBDD.nodeCount() == 0 && subBDD.isZero()) {
						param_condition.free();
						subBDD.free();
						continue;
					}
					if (subBDD.nodeCount() > 1)
						throw new RuntimeException();
					if (subBDD.nodeCount() == 0 && !subBDD.isZero())
						throw new RuntimeException();
					if (!subBDD.high().isOne())
						throw new RuntimeException();
					if (!subBDD.low().isZero())
						throw new RuntimeException();

					int var_id = subBDD.var();
					MappedNode var = bddIdMapping.getNode(var_id);
					tconConfigurations.get(regularInputs.indexOf(var)).orWith(
							param_condition);

					subBDD.free();
				}
				regularLeafSubBDDIterator.free();

				// Create the TCONs that connect to the inputs of the TLUT
				ArrayList<MappedNode> configurations = new ArrayList<MappedNode>();
				for (int i = 0; i < tconConfigurations.size(); i++) {
					String configName = gate.getName() + "_in" + i;
					MappedGate configurationNode = configurationCircuit
							.addParameterisedConfigurationGate(
									configName,
									new BooleanFunction<MappedNode>(
											bddIdMapping, tconConfigurations
													.get(i)));

					MappedInput configInput = circuit.addInput(configName,
							false);
					configurations.add(configInput);
					configurationCircuit.addOutput(configName).setSource(
							configurationNode);
				}

				// Create the TLUT
				mappedN = circuit.addParameterisedMux(gate.getName(),
						regularInputs, configurations);

			} else if (gate.hasParameterSources()) {
				BooleanFunction<MappedNode> function = gate.getFunction()
						.translate(mapping);
				ArrayList<MappedNode> sources = function.getInputVariables();

				ArrayList<MappedNode> regularInputs = new ArrayList<MappedNode>();
				for (MappedNode node : sources)
					if (!node.isParameterInput())
						regularInputs.add(node);

				// Calculate the truth table of the TLUT by performing partial
				// evaluation of the local function
				ArrayList<MappedNode> configurationNodes = new ArrayList<MappedNode>();
				for (TruthAssignment<MappedNode> assignment : TruthAssignmentIterator
						.createFrom(regularInputs)) {
					String configNodeName = gate.getName() + "_"
							+ assignment.getEntry();
					BooleanFunction<MappedNode> configurationFunction = function
							.partialEvaluate(assignment);
					MappedNode configurationNode = configurationCircuit
							.addParameterisedConfigurationGate(configNodeName,
									configurationFunction);
					configurationNodes.add(configurationNode);
				}

				// For practical reasons, even a LUT with x used inputs needs
				// 2^K configuration entries. We duplicate the configuration
				// entries here for compatibility with the existing C-code
				// generator.
				int entry = 0;
				ArrayList<MappedNode> configurations = new ArrayList<MappedNode>();
				for (int i = 0; i < Math.pow(2, K - regularInputs.size()); i++) {
					for (int j = 0; j < Math.pow(2, regularInputs.size()); j++) {
						String configName = gate.getName() + "_" + entry;
						MappedInput configInput = circuit.addInput(configName,
								false);
						configurationCircuit.addOutput(configName).setSource(
								configurationNodes.get(j));
						// The mappedparameterisedgate only expects 2^x
						// configuration entries.
						if (i == 0)
							configurations.add(configInput);
						entry++;
					}
				}

				mappedN = circuit.addParameterisedGate(gate.getName(),
						regularInputs, configurations, gate.getMappedType());
			} else {
				BooleanFunction<MappedNode> function = gate.getFunction()
						.translate(mapping);
				mappedN = circuit.addGate(gate.getName(), function,
						gate.getMappedType());
			}
			mapping.put(gate, mappedN);
		}

		for (MappedPrimaryOutput output : getPrimaryOutputs()) {
			MappedPrimaryOutput mappedO = outputMapping.get(output);
			MappedNode mappedS = mapping.get(output.getSource());
			if (mappedO == null)
				throw new RuntimeException();
			if (mappedS == null)
				throw new RuntimeException();
			mappedO.setSource(mappedS);
		}

		// Sort inputs and outputs to match expected order in ExtractInfo and
		// CGenerator
		// May not be completely safe if gate names end with a number and may be
		// confused with a similar gate name without that number at the end.
		Collections.sort(configurationCircuit.inputs,
				new AlphanumMappedNodeNameComparator());
		Collections.sort(configurationCircuit.outputs,
				new AlphanumMappedNodeNameComparator());

		circuit.sanityCheck();
		configurationCircuit.sanityCheck();

		return new ParameterisedMappedCircuitPair(circuit, configurationCircuit);
	}

	/**
	 * Construct a mapped circuit from another mapped circuit. The new circuit
	 * will only have LUT, TLUT and TCON gates. TLC gates in the original
	 * circuit will be transformed into TLUT and TCON gates. Inversion as part
	 * of a TCON will be extracted from the TCON.
	 */
	public MappedCircuit constructPrimitiveMappedCircuit() {
		MappedCircuit circuit = new MappedCircuit(getName(), K);

		HashMap<MappedNode, MappedNode> mapping = new HashMap<MappedNode, MappedNode>();
		HashMap<MappedPrimaryOutput, MappedPrimaryOutput> outputMapping = new HashMap<MappedPrimaryOutput, MappedPrimaryOutput>();

		// Copy inputs, latches, outputs
		mapping.put(getConst0(), circuit.getConst0());
		mapping.put(getConst1(), circuit.getConst1());
		for (MappedInput in : getInputs()) {
			MappedInput mappedN = circuit.addInput(in.getName(),
					in.isParameter());
			mapping.put(in, mappedN);
		}
		for (MappedOutput out : getOutputs()) {
			MappedOutput mappedN = circuit.addOutput(out.getName());
			outputMapping.put(out, mappedN);
		}
		for (MappedOLatch olatch : getOLatches()) {
			MappedLatchPair mappedNpair = circuit.addLatch(olatch.getName());
			mapping.put(olatch, mappedNpair.getOLatch());
			outputMapping.put(olatch.getILatch(), mappedNpair.getILatch());
		}

		BDDFactory factory = BDDFactorySingleton.get();
		BDDPairing var_replacement = factory.makePair();

		// Create K temporary dummy LUT inputs
		ArrayList<MappedNode> dummyLutInputs = new ArrayList<MappedNode>();
		for (int i = 0; i < K; i++)
			dummyLutInputs.add(circuit.addGate("dummy_lut_input" + i,
					new BooleanFunction<MappedNode>(
							new BDDidMapping<MappedNode>(), factory.one()),
					"DUMMY"));

		for (MappedGate gate : getGatesInTopologicalOrderInToOut()) {
			MappedNode mappedN;
			// Separate the K TCONs connected to the K inputs of the TLUT
			if (gate.getMappedType().equals("TLC")
					|| gate.getMappedType().equals("TCON")) {
				BooleanFunction<MappedNode> function = gate.getFunction()
						.translate(mapping);

				BDDidMapping<MappedNode> bddIdMapping = function
						.getBDDidMapping();
				// Add dummy LUT inputs to bdd id mapping
				// They will be replaced once the real input MappedGates are
				// created
				for (int i = 0; i < K; i++)
					bddIdMapping.mapNodeToId(dummyLutInputs.get(i),
							bddIdMapping.getNextUnusedId());

				// Initialise the function of the TLUT and TCONs
				BDD tlutFunction = factory.zero();
				ArrayList<BDD> tlutInputFunctions = new ArrayList<BDD>();
				for (int i = 0; i < K; i++)
					tlutInputFunctions.add(factory.zero());

				// Warning: this is a bit dangerous. RegularLeafSubBDDIterator
				// requires that all parameters have a lower id than
				// non-parameters. This may not be the case if the local
				// function of a mappedgate has been constructed in some way.
				// This is fine if the bddidmapping still corresponds to the one
				// used in the MappingAIG.
				verifyBDDParamVarMapping(function);
				RegularLeafSubBDDIterator regularLeafSubBDDIterator = new RegularLeafSubBDDIterator(
						function.getBDD(), function.getBDDidMapping());
				while (regularLeafSubBDDIterator.hasNext()) {
					BDDPair pair = regularLeafSubBDDIterator.next();
					BDD param_condition = pair.first;
					BDD subBDD = pair.second;
					BDD lut_support_it = subBDD.support();
					var_replacement.reset();

					// TODO: improve mapping of input signals to physical TLUT
					// inputs
					// Iterate over the support of the subBDD
					int i = 0;
					while (!lut_support_it.isOne()) {
						if (i >= K)
							throw new RuntimeException();
						int var_id = lut_support_it.var();
						BDD n_lut_support_it = lut_support_it.high();
						lut_support_it.free();
						lut_support_it = n_lut_support_it;

						tlutInputFunctions.get(i).orWith(
								param_condition.and(factory.ithVar(var_id)));
						var_replacement.set(var_id,
								bddIdMapping.getId(dummyLutInputs.get(i)));

						i++;
					}

					BDD subBDDrepl = subBDD.replace(var_replacement);
					tlutFunction.orWith(param_condition.and(subBDDrepl));

					subBDDrepl.free();
					param_condition.free();
					subBDD.free();
				}
				regularLeafSubBDDIterator.free();

				// Create the TCONs that connect to the inputs of the TLUT
				for (int i = 0; i < K; i++) {
					MappedGate lutInput = circuit.addGate(gate.getName()
							+ "_in" + i, new BooleanFunction<MappedNode>(
							bddIdMapping, tlutInputFunctions.get(i)), "TMUX");

					// Replace dummy LUT inputs now that the real inputs are
					// finally created
					bddIdMapping.mapNodeToId(lutInput,
							bddIdMapping.getId(dummyLutInputs.get(i)));
				}

				// Create the TLUT
				BooleanFunction<MappedNode> tlutBooleanFunction = new BooleanFunction<MappedNode>(
						bddIdMapping, tlutFunction);
				if (tlutBooleanFunction.isIdentityFunction()) {
					mappedN = tlutBooleanFunction.getInputVariables().get(0);
				} else {
					mappedN = circuit.addGate(gate.getName(),
							tlutBooleanFunction, "TLUT");
				}
			} else {
				BooleanFunction<MappedNode> function = gate.getFunction()
						.translate(mapping);
				mappedN = circuit.addGate(gate.getName(), function,
						gate.getMappedType());
			}
			mapping.put(gate, mappedN);
		}

		// Connect primary outputs
		for (MappedPrimaryOutput output : getPrimaryOutputs()) {
			MappedPrimaryOutput mappedO = outputMapping.get(output);
			MappedNode mappedS = mapping.get(output.getSource());
			if (mappedO == null)
				throw new RuntimeException();
			if (mappedS == null)
				throw new RuntimeException();
			mappedO.setSource(mappedS);
		}

		circuit.removeUnusedGates();
		circuit.sanityCheck();

		return circuit;
	}

	private void verifyBDDParamVarMapping(
			BooleanFunction<? extends IsParameterInterface> function) {
		BDD lut_support_it = function.getBDD().support();
		boolean wasParam = true;
		while (!lut_support_it.isOne()) {
			int var_id = lut_support_it.var();
			BDD n_lut_support_it = lut_support_it.high();
			lut_support_it.free();
			lut_support_it = n_lut_support_it;

			boolean isParam = function.getBDDidMapping().getNode(var_id)
					.isParameter();
			if (!wasParam && isParam)
				throw new RuntimeException("BDD var ordering error");
			wasParam &= isParam;
		}
	}

	/**
	 * Turn a mappedcircuit into an unmapped AIG.
	 */
	public MappingAIG constructAIG() {
		MappingAIG aig = new MappingAIG();

		// Map (the output of) each mappednode to an AIG node
		HashMap<MappedNode, PolarisedNode<Node>> mapping = new HashMap<MappedNode, PolarisedNode<Node>>();

		// Copy consts, inputs, latches
		mapping.put(getConst0(),
				new PolarisedNode<Node>(aig.getConst0(), false));
		mapping.put(getConst1(), new PolarisedNode<Node>(aig.getConst0(), true));
		for (MappedInput input : getInputs()) {
			Node input_cp = aig.addNode(input.getName(), NodeType.INPUT);
			input_cp.setParameter(input.isParameter());
			mapping.put(input, new PolarisedNode<Node>(input_cp, false));
		}
		for (MappedOLatch olatch : getOLatches()) {
			Node olatch_cp = aig.addNode(olatch.getName(), NodeType.OLATCH);
			mapping.put(olatch, new PolarisedNode<Node>(olatch_cp, false));
		}

		// Convert the function of every gate into a piece of the aig
		for (MappedGate gate : getGatesInTopologicalOrderInToOut()) {
			BooleanFunction<MappedNode> functionToTranslate = gate
					.getFunction();

			// Map each bdd node to an aig node (this mapping is local to the
			// specific gate)
			Map<BDD, PolarisedNode<Node>> bddMap = new HashMap<BDD, PolarisedNode<Node>>();

			bddMap.put(BDDFactorySingleton.get().zero(),
					new PolarisedNode<Node>(aig.getConst0(), false));
			bddMap.put(BDDFactorySingleton.get().one(),
					new PolarisedNode<Node>(aig.getConst0(), true));

			// Put gate inputs in mapping
			for (MappedNode n : functionToTranslate.getInputVariables()) {
				PolarisedNode<Node> source_cp = mapping.get(n);
				BDD bddn = BDDFactorySingleton.get().ithVar(
						functionToTranslate.getBDDidMapping().getId(n));
				bddMap.put(bddn, source_cp);
			}

			PolarisedNode<Node> gate_cp = bddToAig_rec(functionToTranslate
					.getBDD().id(), bddMap, aig,
					functionToTranslate.getBDDidMapping());

			mapping.put(gate, gate_cp);
		}

		// Copy outputs
		for (MappedOutput out : getOutputs()) {
			Node output_cp = aig.addNode(out.getName(), NodeType.OUTPUT);
			PolarisedNode<Node> inode_cp = mapping.get(out.getSource());

			Edge e = aig.addEdge(inode_cp.getNode(), output_cp,
					inode_cp.isInverted());
			output_cp.setI0(e);
			inode_cp.getNode().addOutput(e);
		}
		// Copy latches
		for (MappedOLatch olatch : getOLatches()) {
			MappedILatch ilatch = olatch.getILatch();

			PolarisedNode<Node> olatch_cp = mapping.get(olatch);
			Node latch_cp = aig.addNode(olatch.getName(), NodeType.LATCH);
			Node ilatch_cp = aig.addNode(ilatch.getName(), NodeType.ILATCH);
			PolarisedNode<Node> inode_cp = mapping.get(ilatch.getSource());

			Edge olatch_e_cp = aig
					.addEdge(latch_cp, olatch_cp.getNode(), false);
			latch_cp.addOutput(olatch_e_cp);
			olatch_cp.getNode().setI0(olatch_e_cp);
			Edge latch_e_cp = aig.addEdge(ilatch_cp, latch_cp, false);
			ilatch_cp.addOutput(latch_e_cp);
			latch_cp.setI0(latch_e_cp);
			Edge ilatch_e_cp = aig.addEdge(inode_cp.getNode(), ilatch_cp,
					inode_cp.isInverted());
			inode_cp.getNode().addOutput(ilatch_e_cp);
			ilatch_cp.setI0(ilatch_e_cp);
		}

		aig.initBDDidMapping();
		aig.sanityCheck();
		aig.strashCheck();
		return aig;
	}

	private PolarisedNode<Node> bddToAig_rec(BDD bdd,
			Map<BDD, PolarisedNode<Node>> bddMap, AIG<Node, Edge> aig,
			BDDidMapping<MappedNode> bddIdMapping) {
		PolarisedNode<Node> ret;
		if (bddMap.containsKey(bdd)) {
			ret = bddMap.get(bdd);
		} else {
			PolarisedNode<Node> high = bddToAig_rec(bdd.high(), bddMap, aig,
					bddIdMapping);
			PolarisedNode<Node> low = bddToAig_rec(bdd.low(), bddMap, aig,
					bddIdMapping);
			PolarisedNode<Node> varNode = bddMap.get(BDDFactorySingleton.get()
					.ithVar(bdd.var()));

			PolarisedNode<Node> highNode = aig.findNode(high, varNode);
			if (highNode == null)
				highNode = new PolarisedNode<Node>(aig.addNode(null, high,
						varNode), false);
			PolarisedNode<Node> lowNode = aig.findNode(low,
					varNode.toggleInverted(true));
			if (lowNode == null)
				lowNode = new PolarisedNode<Node>(aig.addNode(null, low,
						varNode.toggleInverted(true)), false);

			ret = aig.findNode(lowNode.toggleInverted(true),
					highNode.toggleInverted(true));
			if (ret == null)
				ret = new PolarisedNode<Node>(aig.addNode(null,
						lowNode.toggleInverted(true),
						highNode.toggleInverted(true)), false);
			ret = ret.toggleInverted(true);
		}
		bdd.free();
		return ret;
	}

	public void sanityCheck() {
		HashSet<String> names = new HashSet<String>();
		ArrayList<MappedNode> all_except_outputs = new ArrayList<MappedNode>();
		all_except_outputs.addAll(getInputs());
		all_except_outputs.addAll(getOLatches());
		all_except_outputs.addAll(getGates());
		for (MappedNode node : all_except_outputs) {
			if (names.contains(node.getName()))
				throw new RuntimeException(
						"MappedCircuit sanitycheck error: name already in use: "
								+ node.getName());
			names.add(node.getName());
		}

		HashSet<MappedNode> used_nodes = listUsedNodes();
		HashSet<MappedNode> known_nodes = new HashSet<MappedNode>(getAllNodes());
		for (MappedNode node : used_nodes)
			if (!known_nodes.contains(node))
				throw new RuntimeException(
						"MappedCircuit sanitycheck error: MappedNode referenced but not in circuit's known nodes: "
								+ node.getName());
	}

	public void removeUnusedGates() {
		HashSet<MappedNode> used_nodes = listUsedNodes();
		ArrayList<MappedGate> gates = new ArrayList<MappedGate>();
		for (MappedGate gate : getGates())
			if (used_nodes.contains(gate))
				gates.add(gate);
			else
				gate.removeGate();
		for (MappedOLatch olatch : getOLatches())
			if (!used_nodes.contains(olatch))
				System.out
						.println("WARNING: unused latch: " + olatch.getName());
		this.gates = gates;
	}

	private HashSet<MappedNode> listUsedNodes() {
		HashSet<MappedNode> used_nodes = new HashSet<MappedNode>();
		for (MappedNode output : getPrimaryOutputs())
			listUsedNodes_rec(output, used_nodes);
		return used_nodes;
	}

	private void listUsedNodes_rec(MappedNode node,
			HashSet<MappedNode> used_nodes) {
		if (used_nodes.contains(node))
			return;
		used_nodes.add(node);
		for (MappedNode source : node.getSources())
			listUsedNodes_rec(source, used_nodes);
	}
	
	public int numLUTResourcesUsed() {
		int num_LUT_resources = 0;
		for (MappedNode node : getAllNodes())
			num_LUT_resources += node.numLUTResources();
		return num_LUT_resources;
	}
}
