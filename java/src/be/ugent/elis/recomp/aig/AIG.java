/*
SOFTWARE LICENSE AGREEMENT

This software license agreement (hereinafter referred to as the "Agreement") provides the terms and conditions under which Universiteit Gent - Ghent University (hereinafter referred to as "UGent") is willing to grant you (being the person or entity installing and using the Licensed Software for Non-Commercial Purposes, hereinafter referred to as the "Licensee")  a non-exclusive, limited right to use the Licensed Software under UGent Copyright.

By downloading the Licensed Software, or installing Licensed Software, or using Licensed Software, or clicking on the "accept" button under this Agreement, Licensee agrees to accept the terms and conditions of this Agreement and agrees to be bound by this Agreement. If Licensee does not agree with any of the terms or conditions of this Agreement, he should not download or install or use the Licensed Software. 

(1) Licensee warrants and represents that the person accepting this Agreement on behalf of Licensee is its legally authorized representative and is duly authorized to accept agreements of this type on behalf of Licensee and obligate Licensee to the terms and conditions herein. Any breach of this warranty and representation is a material breach of this Agreement and, in such event, this Agreement and the rights granted to Licensee shall terminate automatically. 

(2) Definitions  -  For the purposes of this Agreement, the following terms shall have the following meanings:
a) "Software":  refers to the computer software supplied with this Agreement named "tlut flow" and provided in Python and Java code form. 
b) "Licensed Software":  refers to the Software, and any other computer software and documentation, if any, supplied with this Agreement. 
c) "Adaptation":  refers to any work based on the Licensed Software, including: 
    1) any work which incorporates all or part of the Licensed Software, 
    2) any work which includes modifications to the Software, including but not limited to bug fixes, 
    3) any work which would be regarded as a derivative work of the Software under the Belgian Copyright Law, and 
    4) any work which is otherwise covered by any of UGent's intellectual property rights in the Licensed Software. 
d) "Grant Back Software":  refers to any
        1) modification of the objects distributed as the Software, including but not limited to the addition, deletion, and modification of verbs and properties on the objects, 
        2) creation of children to the objects distributed as the Software. 
e) "Copyright Holder": refers to Universiteit Gent - Ghent University, public institution with legal personality, having its administrative offices in Belgium, B-9000 Gent, Sint-Pietersnieuwstraat 25 (herein also referred to as "UGent")
f) "Non-Commercial Purpose":  refers to use of the Licensed Software solely for the purpose of education or research. "Non-Commercial Purpose" excludes, without limitation, any use of the Software as part of or in connection with a product (including software) or service which is sold, offered for sale, licensed, leased, loaned or rented.

(3) Adaptations  -  Licensee may create Adaptations of the Licensed Software only if 
    a. Licensee treats the Adaptations as Licensed Software under this Agreement, and 
    b. the Adaptations include all copyright notices appearing in the Licensed Software, and 
    c. any Adaptations of the Licensed Software do not disable, modify or change the Licensed Software's requirement that an end-user accept the terms and conditions of the license agreement(s) contained in such Licensed Software before use and/or installation and 
    d. any Adaptations of the Licensed Software do not modify or change the terms and conditions of such license agreement(s). 

(4) Grant Back  -  Licensee hereby grants UGent a non-exclusive, royalty-free, fully paid-up, worldwide, perpetual license to: 
    a. Reproduce and prepare derivative works based on and distribute all or part of any Grant Back Software; and 
    b. make, have made, use, offer to sell, sell, license or import any products (including software) or services under any intellectual property rights owned or licensed by Licensee which relate to (1) all or part of any Grant Back Software or  (2) methods or concepts embodied in, or implemented through the execution of any Grant Back Software.
Licensee shall provide UGent with copies of Grant Back Software in source code form dirk.stroobandt@ugent.be. 

(5) Distributing and Receiving Adaptations  -  Licensee may provide an Adaptation to other people or entities only if:
    a. either such other people or entities have already downloaded the Licensed Software directly from UGent and have agreed to the same terms as this Agreement, and 
    b. the Adaptation is provided by Licensee for Non-Commercial Purposes, without any charge or fee, 
    c. the Adaptation is provided with a short summary of the difference between the Adaptation and the Licensed Software downloaded from UGent, 
    d. such other people or entities treat the Adaptation as Licensed Software under this Agreement with UGent, and 
    e. before Licensee sends such Adaptation to any other people or entities, Licensee first provides UGent with a copy of the Adaptation (in source code form) and the summary. 
Licensee shall treat as Licensed Software under this Agreement any Adaptation it may receive from another person or entity.

(6) No Other Rights  -  Licensee acknowledges that it obtains no ownership rights in the Licensed Software under the terms of this Agreement. All rights in the Licensed Software including but not limited to trade secrets, trademarks, service marks, patents, and copyrights are, shall be and will remain the property and ownership of UGent. All copies of the Licensed Software delivered to Licensee or made by Licensee remain the property of UGent. Except as expressly authorized under this Agreement, Licensee shall not use, copy, distribute, display or transfer the licensed software in any form.

(7) Third party rights  -  Licensee warrants that it has obtained lawful permission to use all hardware and software required in order to use the Licensed Software including but not limited to obtaining appropriate licenses to use and create software in the Java and Python program languages.

(8) Warranty Disclaimer  -  UGent has no obligation to support or maintain the Licensed Software and grants Licensee this right to use the Licensed Software "as is". Licensee, and anyone to whom Licensee provides the Licensed Software pursuant to this Agreement, assume total responsibility and risk for Licensee's use of the Licensed Software. UGent does not make, and expressly disclaims, any express or implied warranties, representations or endorsements of any kind whatsoever, including, without limitation, the implied warranties of merchantability or fitness for a particular purpose, and the warranties of title or non-infringement.

In no event shall UGent be liable for 
	(a) any incidental, consequential, or indirect damages (including, without limitation, damages for loss of profits, business interruption, loss of programs or information, and the like) arising out of the use of or inability to use the Licensed Software, even if UGent or any of its authorized representatives has been advised of the possibility of such damages, 
	(b) any claim attributable to errors, omissions, or other inaccuracies in the Licensed Software, or 
	(c) any claim by any third party. 
By way of example only, UGent does not warrant that the Licensed Software will be error-free. As used in this section, "UGent" includes its employees, directors, officers, agents, representatives, subcontractors, service providers and suppliers. 

(9) Sole Remedy  -  If for any reason the Software is unusable or does not perform as Licensee intended or expected, then Licensee's sole remedy shall be to either terminate this Agreement or to modify the Software to create an Adaptation which is usable or performs as intended or expected. This limitation on remedies shall apply even if Licensee cannot modify the Software to make the Software usable or perform as intended or expected. Because some states do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to Licensee. In the event applicable state or federal law does not allow the complete exclusion of any warranties as set forth in this Agreement, UGent's liability is limited to the greatest extent permitted by law.

(10) Communications  -  By downloading and installing the Licensed Software, Licensee agrees that UGent may send e-mail messages or communications relating to the Licensed Software to Licensee, its employees and representatives.

(11) Termination  -  This Agreement and the rights granted to Licensee shall terminate automatically if Licensee fails to comply with any of the terms and conditions of this Agreement. Upon termination, all licenses granted herein shall terminate and Licensee shall immediately destroy all copies of the Licensed Software. 

(12) Applicable Law  -  This Agreement shall be governed by and construed in accordance with the laws of the Belgium, without regard to its conflicts of law rules. The Commercial courts of Gent, Belgium are exclusively competent. 

(13) Assignment  -  Neither this Agreement nor any of Licensee's rights hereunder shall be assigned, sublicensed, or transferred (in insolvency proceedings, by mergers, acquisitions or otherwise) by Licensee without the written consent of UGent. Any assignment or other transfer which is inconsistent with the foregoing shall be null and void ab initio. UGent may assign all or a portion of its rights and obligations hereunder. 

Copyright (c) 2012, Ghent University - HES group
All rights reserved.
*//*
*/
package be.ugent.elis.recomp.aig;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Set;
import java.util.Vector;
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

import be.ugent.elis.recomp.mapping.utils.AlphanumNodeNameComparator;
import be.ugent.elis.recomp.mapping.utils.Cone;
import be.ugent.elis.recomp.mapping.utils.Node;
import be.ugent.elis.recomp.mapping.utils.PolarisedNode;


public class AIG< N extends AbstractNode<N,E>, E extends AbstractEdge<N,E>> {
	
	final N      const0;
	
	ArrayList<N> input;
	
	ArrayList<N> ilatch;
	ArrayList<N> latch;
	ArrayList<N> olatch;
	
	ArrayList<N> and;
	
	ArrayList<N> output;
	
	ArrayList<E> edges;
	
	ElementFactory<N,E> factory;
	
	Map<String,N> nodeMap;
	HashMap<StrashKey<N, E>, N> strashMap;

	public AIG(ElementFactory<N,E> factory){
		input  = new ArrayList<N>();
		ilatch = new ArrayList<N>();
		latch  = new ArrayList<N>();
		olatch = new ArrayList<N>();
		and    = new ArrayList<N>();
		output = new ArrayList<N>();
		edges  = new ArrayList<E>();
		
		this.factory = factory;
		this.const0 = this.factory.newConst0(this);
		
		strashMap = new HashMap<StrashKey<N,E>,N>();
	}
	
	public AIG(ElementFactory<N,E> factory, String fileName) throws FileNotFoundException{
		this(factory);
		
		readAAG(fileName);
	}
	
	public AIG(AIG<N,E> aig) {
		this(aig.factory);
		
		Map<N,N> copyMap = new HashMap<N,N>();
		
		//Copy the nodes
		for (N node : aig.getAllNodes()) {
			N node_copy = addNode(node.getName(), node.getType());
			copyMap.put(node, node_copy);
		}
		
		//Copy the edges
		for (E edge : aig.getAllEdges()) {
			N tail_copy = copyMap.get(edge.getTail());
			N head_copy = copyMap.get(edge.getHead());
			
			E edge_copy = addEdge(tail_copy, head_copy, edge.isInverted());
			
			tail_copy.addOutput(edge_copy);
			head_copy.setI(edge.getInputIndex(), edge_copy);
		}
	}
    

	public void copyStrash(AIG<N,E> aig) {
		Map<N,PolarisedNode<N>> propagateMap = new HashMap<N,PolarisedNode<N>>();
		
		//Copy primary inputs
		for (N node : aig.getAllPrimaryInputs()) {
			N node_copy = addNode(node.getName(), node.getType());
			propagateMap.put(node, new PolarisedNode<N>(node_copy, false));
		}
		
		//Propagate constants and strash and nodes at the same time
		for (N orig : aig.topologicalOrderInToOut(false, false)) {
			E e0 = orig.getI0();
			E e1 = orig.getI1();
			
			N origI0 = e0.getTail();
			PolarisedNode<N> pnodeI0 = propagateMap.get(origI0);
			pnodeI0 = pnodeI0.toggleInverted(e0.isInverted());
			
			N origI1 = e1.getTail();
			PolarisedNode<N> pnodeI1 = propagateMap.get(origI1);
			pnodeI1 = pnodeI1.toggleInverted(e1.isInverted());
			
			PolarisedNode<N> copy = this.findNode(pnodeI0, pnodeI1);
			if (copy == null)
				copy = new PolarisedNode<N>(this.addNode(orig.getName(), pnodeI0, pnodeI1), false);
			propagateMap.put(orig, copy);
		}
		
		// Copy latches
		for (N olatch : aig.getOLatches()) {
			N latch = olatch.getI0().getTail();
			N ilatch = latch.getI0().getTail();
			if(!ilatch.isILatch()) 
				throw new RuntimeException("Grandparent of OLatch is expected to be ILatch");
			E iedge = ilatch.getI0();
			N inode = iedge.getTail();
			
			PolarisedNode<N> olatch_cp_pn = propagateMap.get(olatch);
			N olatch_cp = olatch_cp_pn.getNode();
			if(!olatch_cp.isOLatch())
				throw new RuntimeException("Copy of OLatch is supposed to be OLatch");
			N latch_cp = addNode(latch.getName(), NodeType.LATCH);
			N ilatch_cp = addNode(ilatch.getName(), NodeType.ILATCH);
			PolarisedNode<N> inode_cp_pn = propagateMap.get(inode);
			inode_cp_pn = inode_cp_pn.toggleInverted(iedge.isInverted());
			N inode_cp = inode_cp_pn.getNode();

			E olatch_e_cp = addEdge(latch_cp, olatch_cp, false);
			latch_cp.addOutput(olatch_e_cp);
			olatch_cp.setI0(olatch_e_cp);
			E latch_e_cp = addEdge(ilatch_cp, latch_cp, false);
			ilatch_cp.addOutput(latch_e_cp);
			latch_cp.setI0(latch_e_cp);
			E ilatch_e_cp = addEdge(inode_cp, ilatch_cp, inode_cp_pn.isInverted());
			inode_cp.addOutput(ilatch_e_cp);
			ilatch_cp.setI0(ilatch_e_cp);
		}
		
		// Copy outputs
		for (N output : aig.getOutputs()) {
			E iedge = output.getI0();
			N inode = iedge.getTail();

			N output_cp = addNode(output.getName(), NodeType.OUTPUT);
			PolarisedNode<N> inode_cp_pn = propagateMap.get(inode);
			inode_cp_pn = inode_cp_pn.toggleInverted(iedge.isInverted());
			N inode_cp = inode_cp_pn.getNode();
			
			E copy_e = addEdge(inode_cp, output_cp, inode_cp_pn.isInverted());
			inode_cp.addOutput(copy_e);
			output_cp.setI0(copy_e);
		}
		
		removeUnusedNodes();
		sanityCheck();
		strashCheck();
	}
	
	private void readAAG(String filename) throws FileNotFoundException {
		
		FileInputStream stream = new FileInputStream(new File(filename));
		Scanner scan = new Scanner(stream);
		
		scan.next();
		int M = scan.nextInt();
		int I = scan.nextInt();
		int L = scan.nextInt();
		int O = scan.nextInt();
		int A = scan.nextInt();

		Vector<N> variable = new Vector<N>();
		variable.setSize(M+1);
		
		
		variable.set(0, this.const0);
				
		for (int i=0; i<I; i++) {
			int var = scan.nextInt()/2;
			N in =  factory.newInput(this);
			input.add(in);
			variable.set(var,in);
		}
		
		for (int l=0;l<L; l++) {
			int lit = scan.nextInt();
			scan.nextInt();
			N ilatch = factory.newILatch(this);
			this.ilatch.add(ilatch);
			N latch  = factory.newLatch(this);
			this.latch.add(latch);			
			N olatch = factory.newOLatch(this);
			this.olatch.add(olatch);
			
			variable.set(lit/2, olatch);
		}
		
		for (int o=0; o<O; o++) {
			scan.nextInt();
			N out = factory.newOutput(this);
			output.add(out);
		}
		
		for (int i=0; i<A; i++) {
			int lit = scan.nextInt();
			scan.nextInt();
			scan.nextInt();
			N and = factory.newAnd(this);
			
			and.setName("a"+Integer.toString(lit));
			
			this.and.add(and);
			variable.set(lit/2, and);
		}
		
		//Setting the symbol names
		try {
            String word = scan.next();
            while (word.charAt(0) != 'c') {
                    int index = Integer.parseInt( word.substring(1) );
                    switch (word.charAt(0)) {
                    case 'i':
                            variable.get(index+1).setName(scan.next());
                            break;
                    case 'o':
                            output.get(index).setName(scan.next());
                            break;
                    case 'l':
                            String name = scan.next();
                            ilatch.get(index).setName(name+"_i");
                            latch.get(index).setName(name);
                            olatch.get(index).setName(name);
                            break;
                    default:
                            break;
                    }
                    word = scan.next();
            }
        } catch (NoSuchElementException e) {}
		scan.close();
		
		
		//Second pass: setting the edges
		stream = new FileInputStream(new File(filename));
		scan = new Scanner(stream);
		
		scan.next();
		scan.nextInt();
		scan.nextInt();
		scan.nextInt();
		scan.nextInt();
		scan.nextInt();


		for (int i=0; i<I; i++) {
			scan.nextInt();
		}
		
		for (int l=0; l<L; l++) {
			scan.nextInt();
			int lit = scan.nextInt();
			
			N ilatch = this.ilatch.get(l);
			N latch  = this.latch.get(l);
			N olatch = this.olatch.get(l);
			
			E edge = addEdge(variable.get(lit/2), ilatch, literalIsInverted(lit));
			ilatch.setI0(edge);
			edge.getTail().addOutput(edge);
			
			E iedge = addEdge(ilatch , latch , false);
			latch.setI0(iedge);
			ilatch.addOutput(iedge);

			E oedge = addEdge(latch , olatch , false);
			olatch.setI0(oedge);
			latch.addOutput(oedge);
		}
		
		for (int o=0; o<O; o++) {
			int lit = scan.nextInt();

			N out = this.output.get(o);
			
			E edge = addEdge(variable.get(lit/2), out, literalIsInverted(lit));
			
			out.setI0(edge);
			
			edge.getTail().addOutput(edge);

		}
		
		for (int i=0; i<A; i++) {
			scan.nextInt();
			int lit0 = scan.nextInt();
			int lit1 = scan.nextInt();
			
			N and = this.and.get(i);

			E edge0 = addEdge(variable.get(lit0/2), and,literalIsInverted(lit0));

			E edge1 = addEdge(variable.get(lit1/2), and,literalIsInverted(lit1));
			
			and.setI0(edge0);
			and.setI1(edge1);
			
			edge0.getTail().addOutput(edge0);
			edge1.getTail().addOutput(edge1);
		}
		scan.close();

		removeUnusedNodes();
		sanityCheck();
	}

	private boolean literalIsInverted(int lit) {
		boolean inverted;
		if (lit%2 == 1) { 
			inverted = true;
		} else {
			inverted = false;
		}
		return inverted;
	}

	public void setMarkedAll(boolean marked) {
		for (N n: getAllNodes()) {
			n.setMarked(marked);
		}
	}
	
	public int numNodes() {
		return input.size() +
			and.size() +
			output.size() +
			ilatch.size() +
			latch.size() +
			olatch.size() +
			1; //const0
	}

	public ArrayList<N> getAllNodes() {
		ArrayList<N> all = new ArrayList<N>();
		all.addAll(input);
		all.addAll(and);
		all.addAll(output);
		all.addAll(ilatch);
		all.addAll(latch);
		all.addAll(olatch);
		all.add(const0);
		return all;
	}

	public ArrayList<N> getAllPrimaryInputs() {
		ArrayList<N> all = new ArrayList<N>();
		all.addAll(input);
		all.addAll(olatch);
		all.add(const0);
		return all;
	}
	
	public ArrayList<N> getAllPrimaryOutputs() {
		ArrayList<N> all = new ArrayList<N>();
		all.addAll(output);
		all.addAll(ilatch);
		return all;
	}
	
	public N getNode(String name) {
		if (nodeMap == null) {
			nodeMap = new HashMap<String,N>();
			for (N node: getAllNodes()) {
				nodeMap.put(node.name, node);
			}
		}
		return nodeMap.get(name); 
	}

	public void visitAll(Visitor<N,E> visitor) {
		visitor.init(this);
		for (N node: this.topologicalOrderInToOut(true, true)) {
			visitor.visit(node);			
		}
		visitor.finish(this);
	}
	
	public void visitAll(Visitor<N,E> visitor1, Visitor<N,E> visitor2, Visitor<N,E> visitor3) {
		visitor1.init(this);
		visitor2.init(this);
		visitor3.init(this);
		for (N node: this.topologicalOrderInToOut(true, true)) {
			visitor1.visit(node);
			visitor2.visit(node);
			visitor3.visit(node);			
		}
		visitor1.finish(this);
		visitor2.finish(this);
		visitor3.finish(this);
	}
	
	public Vector<N> topologicalOrderInToOut(boolean includeInputs, boolean includeOutputs ) {
		setMarkedAll(false);
		
		Vector<N> intoout = new Vector<N>();
		for (N out : getAllPrimaryOutputs()) {
			inToOut_rec(out, intoout, includeInputs, includeOutputs);
		}
		
		setMarkedAll(false);
		return intoout;
	}
	
	public Vector<N> getAllVisibleAnds() {
		return topologicalOrderInToOut(false, false);
	}

	private Vector<N> inToOut_rec(N node, Vector<N> vec, boolean includeInputs, boolean includeOutputs) {
		if (!node.isMarked()) {
			switch (node.getType()) {
			case AND:
				inToOut_rec(node.in0Node(), vec, includeOutputs, includeOutputs);
				inToOut_rec(node.in1Node(), vec, includeOutputs, includeOutputs);
				vec.add(node);
				node.setMarked(true);
				break;
			case INPUT:
			case OLATCH:
			case CONST0:
				if (includeInputs)
					vec.add(node);
				node.setMarked(true);
				break;
			case OUTPUT:
			case ILATCH:
				inToOut_rec(node.in0Node(), vec, includeOutputs, includeOutputs);
				if (includeOutputs)
					vec.add(node);
				node.setMarked(true);
				break;
			default:
				break;
			}
		}
		return vec;
	}

	public void visitAllInverse(Visitor<N,E> visitor) {
		visitor.init(this);
		for (N node: this.topologicalOrderOutToIn()) {
			visitor.visit(node);			
		}
		visitor.finish(this);
	}

	public Vector<N> topologicalOrderOutToIn() {
		setMarkedAll(false);
		
		Vector<N> intoout = new Vector<N>();
		for (N out : getAllPrimaryOutputs()) {
			outToIn_rec(out, intoout);
		}
		
		setMarkedAll(false);
		return intoout;
	}


	private Vector<N> outToIn_rec(N node, Vector<N> vec) {
		if (!node.isMarked()) {
			switch (node.getType()) {
			case AND:
				if(node.allFanoutIsMarked()) {
					vec.add(node);
					node.setMarked(true);
					outToIn_rec(node.in0Node(), vec);
					outToIn_rec(node.in1Node(), vec);
				}
				break;
			case INPUT:
			case OLATCH:
			case CONST0:
				if(node.allFanoutIsMarked()) {
					vec.add(node);
					node.setMarked(true);
				}
				break;
			case OUTPUT:
			case ILATCH:
				vec.add(node);
				node.setMarked(true);
				outToIn_rec(node.in0Node(), vec);
				break;
			default:
				break;
			}	
		}
		return vec;
		
	}

	public ArrayList<N> getInputs() {
		return input;
	}

	public ArrayList<N> getOutputs() {
		return output;
	}

	public ArrayList<N> getAnds() {
		return and;
	}

	public ArrayList<N> getLatches() {
		return latch;
	}

	public ArrayList<N> getILatches() {
		return ilatch;
	}

	public ArrayList<N> getOLatches() {
		return olatch;
	}
	
	public N getConst0() {
		return const0;
	}
	
	public boolean hasLatch() {
		if (latch.isEmpty())
			return false;
		else
			return true;
	}

	public ArrayList<E> getAllEdges() {
		return edges;
	}
	
	public void printAAG(PrintStream stream) {
		ArrayList<N> variable = new ArrayList<N>();
		variable.add(const0);
		variable.addAll(input);
		variable.addAll(olatch);
		variable.addAll(and);
		
//		Vector<N> andsTopoOrder = this.topologicalOrderInToOut(false, false);
//		variable.addAll(andsTopoOrder);
		
		Map<N,Integer> variableIndex = new HashMap<N,Integer>();
		for (int i=0; i<variable.size(); i++) {
			variableIndex.put(variable.get(i), i);
		}
		
		stream.println("aag "+ (variable.size()-1) + " " + input.size() + " " + latch.size() + " " + output.size() + " " + and.size());
		
		for (N n: input) {
			int var = 2* variableIndex.get(n);
			stream.println(var);
		}
		
		for (N n: olatch) {
			int var = 2* variableIndex.get(n);
			
			N latch = n.getI0().getTail();
			N ilatch = latch.getI0().getTail();
			int lit = 2* variableIndex.get(ilatch.getI0().getTail());
			if (ilatch.getI0().isInverted()) {
				lit += 1; 
			}
			
			stream.println(var+ " " + lit);
		}
		
		for (N n: output) {
			int lit = 2 * variableIndex.get(n.getI0().getTail());
			if (n.getI0().isInverted()) {
				lit += 1;
			}
			
			stream.println(lit);
		}
		
//		for (N n: andsTopoOrder) {
		for (N n: and) {
			int var = 2* variableIndex.get(n);
			
			int lit0 = 2 * variableIndex.get(n.getI0().getTail());
			if (n.getI0().isInverted()) {
				lit0 += 1;
			}
			
			int lit1 = 2 * variableIndex.get(n.getI1().getTail());
			if (n.getI1().isInverted()) {
				lit1 += 1;
			}
			
			if ( lit0 >= lit1)
				stream.println(var+ " " + lit0 + " " + lit1);
			else 
				stream.println(var+ " " + lit1 + " " + lit0);
		}
		
		//Symbol names
		for (int i=0; i<input.size(); i++) {
			stream.println ("i"+ i +" "+ input.get(i).getName());
		}

		for (int l=0; l<latch.size(); l++) {
			stream.println ("l"+ l +" "+ latch.get(l).getName());
		}
		
		for (int o=0; o<output.size(); o++) {
			stream.println("o"+ o + " " + output.get(o).getName());
		}
		
		stream.println("c");
		stream.println();	
		stream.flush();
	}

	public void printGraph(PrintStream stream) {
		
		stream.println("digraph G {");
		
		stream.println("{");
		stream.println("  rank = same;");
		for (N n: input) {
//			stream.println(n.getName()+"[shape = point, style = filled, fillcolor = white, width = 0.3];");
			stream.println(n.getName()+";");
		}
		stream.println("}");		
		
		stream.println("{");
		stream.println("  rank = same;");
		for (N n: output) {
//			stream.println(n.getName()+"[shape = point, style = filled, fillcolor = white, width = 0.3];");
			stream.println(n.getName()+";");
		}
		stream.println("}");		


		for (E e: edges) {
			stream.print(e.getTail().getName() + " -> " + e.getHead().getName());
			if (e.isInverted()) {
				stream.print("[arrowhead = dot]");
			}
			stream.println(";");
		}
		
		stream.println("}");
		stream.flush();
	}
	
	
	public void printAAGevaluator(PrintStream stream) {
		
		Vector<N> variable = new Vector<N>();
		variable.add(const0);
		variable.addAll(input);
		variable.addAll(and);
		
		Map<N,Integer> variableIndex = new HashMap<N,Integer>();
		for (int i=0; i<variable.size(); i++) {
			variableIndex.put(variable.get(i), i);
		}
		
		
		stream.println("void evaluate(int *parameter, int *output) {");
		
		stream.println("	int node["+variable.size()+"];");
		
		stream.println("	node[0] = 0;");
		
		for (int i=0; i<input.size(); i++) {
			N n = input.get(i);
			int current = variableIndex.get(n);
			stream.println("	node["+current+"] = parameter["+i+"];");
		}
		
		
		for (N n: this.topologicalOrderInToOut(false, true)) {
			
			switch (n.getType()) {
			case AND:
				int current = variableIndex.get(n);
				int child0  = variableIndex.get(n.getI0().getTail());
				int child1  = variableIndex.get(n.getI1().getTail());
				
				stream.print("	node["+current+"] = ");

				if (n.getI0().isInverted()) {
					stream.print("!");
				}
				stream.print("node["+child0+"]");
				
				stream.print(" && ");

				if (n.getI1().isInverted()) {
					stream.print("!");
				}
				stream.print("node["+child1+"]");

				stream.println(";");
				
				break;
				
			case OUTPUT:
				int out = this.output.indexOf(n);
				int child  = variableIndex.get(n.getI0().getTail());
				
				stream.println("	output["+out+"] = node["+child+"];");

				break;
				
			default:
				break;
			}
			
		}

		stream.println("}");
		
		stream.println("void main() {");
		stream.println("	int i;");
		stream.println("	int parameter["+this.input.size()+"];");
		stream.println("	int output["+this.output.size()+"];");
		stream.println("	for (i=0;i<1000;i++) {");
		stream.println("		evaluate(parameter,output);");
		stream.println("	}");
		stream.println("}");
		
		
		stream.flush();
	}

	public void printAAGevaluator2(PrintStream stream) {
		int max = 0;
		StringBuilder file = new StringBuilder();
		String newLine = System.getProperty("line.separator");
		Vector<N> inToOut = topologicalOrderInToOut(true, true);
		setMarkedAll(false);
		
		PriorityQueue<Integer> freeVariablePool = new PriorityQueue<Integer>();
		for (int i = 0; i < 2 + input.size() + and.size(); i++) {
			freeVariablePool.add(i);
		}
	
		Map<N,Integer> variableIndex = new HashMap<N,Integer>();
		
		file.append("void evaluate(int *parameter, int *output) {"+newLine);
		
		file.append("	int node[??];"+newLine);

		variableIndex.put(const0, freeVariablePool.poll());
		file.append("	node["+variableIndex.get(const0)+"] = 0;"+newLine);

		
		for (N n: inToOut) {
			System.out.println(n.getName());
			
			switch (n.getType()) {
			case INPUT:
				variableIndex.put(n, freeVariablePool.poll());
				file.append("	node["+variableIndex.get(n)+"] = parameter["+input.indexOf(n)+"];"+newLine);//

				break;
			case AND:
				variableIndex.put(n, freeVariablePool.poll());

				int current = variableIndex.get(n);
				
				
				int child0  = variableIndex.get(n.getI0().getTail());
				int child1  = variableIndex.get(n.getI1().getTail());
				
				file.append("	node["+current+"] = ");

				if (n.getI0().isInverted()) {
					file.append("!");
				}
				file.append("node["+child0+"]");
				
				file.append(" && ");

				if (n.getI1().isInverted()) {
					file.append("!");
				}
				file.append("node["+child1+"]");

				file.append(";"+newLine);
				
				
				n.setMarked(true);
				
				if (n.getI0().getTail().allFanoutIsMarked()) {
					freeVariablePool.add(child0);
					variableIndex.remove(n.getI0().getTail());
				}

				if (n.getI1().getTail().allFanoutIsMarked()) {
					freeVariablePool.add(child1);
					variableIndex.remove(n.getI1().getTail());
				}

				
				break;
				
			case OUTPUT:
				int out = this.output.indexOf(n);
				int child  = variableIndex.get(n.getI0().getTail());
				
				if (n.getI0().isInverted()) {
					file.append("	output["+out+"] = !node["+child+"];"+newLine);
				}else{
					file.append("	output["+out+"] = node["+child+"];"+newLine);
				}
				
				
				
				n.setMarked(true);

				break;
				
			default:
				break;
			}
			
			if (freeVariablePool.peek() > max) {
				max = freeVariablePool.peek();
			}
			
		}
		

		file.append("}"+newLine);
		
		file.append("void main() {"+newLine);
		file.append("	int i;"+newLine);
		file.append("	int parameter["+this.input.size()+"];"+newLine);
		file.append("	int output["+this.output.size()+"];"+newLine);
		file.append("	for (i=0;i<1000;i++) {"+newLine);
		file.append("		evaluate(parameter,output);"+newLine);
		file.append("	}"+newLine);
		file.append("}"+newLine);
		
		stream.print(file.toString().replace("??", ""+max));
		
		stream.flush();
		
		System.out.println("Maximum index: " + max);
	}

	public void printAAGevaluatorXilinx(PrintStream cstream, PrintStream hstream, String headerFileName, String fpgaFamily) {
		int max = 0;
		StringBuilder cfile = new StringBuilder();
		StringBuilder hfile = new StringBuilder();
		String newLine = System.getProperty("line.separator");
		Vector<N> inToOut = topologicalOrderInToOut(true, true);
		setMarkedAll(false);
		
		PriorityQueue<Integer> freeVariablePool = new PriorityQueue<Integer>();
		for (int i = 0; i < 2 + input.size() + and.size(); i++) {
			freeVariablePool.add(i);
		}
		
		int lutSize = 0;
		if(fpgaFamily.equals("virtex2pro"))
		    lutSize = 16;
		else if(fpgaFamily.equals("virtex5"))
		    lutSize = 64;
		else {
		    System.err.println("Error: Unsupported FPGA family: "+fpgaFamily);
		    System.exit(1);
		}
	
		Map<N,Integer> variableIndex = new HashMap<N,Integer>();
		
		hfile.append("//WARNING: Don't edit. Automatically regenerated file (TLUT flow)"+newLine);
		hfile.append("#include \"xutil.h\""+newLine);
		hfile.append("#include \"xbasic_types.h\""+newLine);
		hfile.append("#include \"locations.h\""+newLine+newLine);
		hfile.append("#include <xhwicap.h>"+newLine+
		    "#include <xstatus.h>"+newLine+
		    "#include <xparameters.h>"+newLine+newLine);
		
		if(fpgaFamily.equals("virtex2pro"))
		    hfile.append("#define HWICAP_DEVICEID       XPAR_OPB_HWICAP_0_DEVICE_ID"+newLine);
		else if(fpgaFamily.equals("virtex5"))
		    hfile.append("#define HWICAP_DEVICEID       XPAR_HWICAP_0_DEVICE_ID"+newLine);
		hfile.append("#define XHI_TARGET_DEVICEID   XHI_READ_DEVICEID_FROM_ICAP"+newLine);
		hfile.append(
		    "#define LUT_CONFIG_WIDTH   "+lutSize+newLine+
		    "#define NUMBER_OF_PARAMETERS  "+this.input.size()+newLine+newLine);
		


		hfile.append("void evaluate(Xuint8 parameter[NUMBER_OF_PARAMETERS], Xuint8 output[NUMBER_OF_TLUTS_PER_INSTANCE][LUT_CONFIG_WIDTH]);"+newLine);
		hfile.append("void reconfigure(XHwIcap *HwIcap, Xuint8 newtruthtables[NUMBER_OF_TLUTS_PER_INSTANCE][LUT_CONFIG_WIDTH], const lutlocation location[] );"+newLine);
		
		
		cfile.append("//WARNING: Don't edit. Automatically regenerated file (TLUT flow)"+newLine);
		cfile.append("#include \""+headerFileName+"\""+newLine);
		if(fpgaFamily.equals("virtex2pro"))
		    cfile.append("#include <xhwicap_clb_lut.h>"+newLine+newLine);
		else if(fpgaFamily.equals("virtex5"))
		    cfile.append("#include \"xhwicap_clb_lut_replacement.h\""+newLine+newLine);
        cfile.append("void evaluate(Xuint8 parameter[NUMBER_OF_PARAMETERS], Xuint8 output[NUMBER_OF_TLUTS_PER_INSTANCE][LUT_CONFIG_WIDTH]) {"+newLine);
		
		cfile.append("	Xuint8 node[??];"+newLine);

		variableIndex.put(const0, freeVariablePool.poll());
		cfile.append("	node["+variableIndex.get(const0)+"] = 0;"+newLine);

		
		for (N n: inToOut) {
			//System.out.println(n.getName());
			
			switch (n.getType()) {
			case INPUT:
				variableIndex.put(n, freeVariablePool.poll());
                if (freeVariablePool.peek() > max)
                    max = freeVariablePool.peek();
                    
				cfile.append("	node["+variableIndex.get(n)+"] = parameter["+input.indexOf(n)+"];");
			    cfile.append("\t//"+input+newLine);
				break;
				
			case AND:
				variableIndex.put(n, freeVariablePool.poll());
                if (freeVariablePool.peek() > max)
                    max = freeVariablePool.peek();

				int current = variableIndex.get(n);
				
				int child0  = variableIndex.get(n.getI0().getTail());
				int child1  = variableIndex.get(n.getI1().getTail());
				
				cfile.append("	node["+current+"] = ");
				if (n.getI0().isInverted()) {
					cfile.append("~");
				}
				cfile.append("node["+child0+"]");
				cfile.append(" & ");
				if (n.getI1().isInverted()) {
					cfile.append("~");
				}
				cfile.append("node["+child1+"]");
				cfile.append(";"+newLine);
				
				n.setMarked(true);
				
				if (n.getI0().getTail().allFanoutIsMarked()) {
					freeVariablePool.add(child0);
					variableIndex.remove(n.getI0().getTail());
				}

				if (n.getI1().getTail().allFanoutIsMarked()) {
					freeVariablePool.add(child1);
					variableIndex.remove(n.getI1().getTail());
				}
				break;
				
			case OUTPUT:
				int out = this.output.indexOf(n);
				int child  = variableIndex.get(n.getI0().getTail());
			    //System.out.println("output ("+n+"="+(out/lutSize)+","+(out%lutSize)+")");
				
				if (n.getI0().isInverted() ^ fpgaFamily.equals("virtex2pro")) { //virtex2pro: all bits inverted
					cfile.append("	output["+(out/lutSize)+"]["+(out%lutSize)+"] = ~node["+child+"] & 1;");
				} else {
					cfile.append("	output["+(out/lutSize)+"]["+(out%lutSize)+"] = node["+child+"] & 1;");
				}
			    cfile.append("\t//"+n+newLine);
				n.setMarked(true);
				break;
				
			default:
				break;
			}
		}
		

		cfile.append("}"+newLine+newLine);
		cfile.append("//reconfigure one instance"+newLine);
		cfile.append("void reconfigure(XHwIcap *HwIcap, Xuint8 newtruthtables[NUMBER_OF_TLUTS_PER_INSTANCE][LUT_CONFIG_WIDTH], const lutlocation location[] ) {"+newLine);
		cfile.append("	//reconfigure all the TLUTs one by one"+newLine);
		cfile.append("	Xuint8 i;"+newLine);
		cfile.append("	for(i =0;i<NUMBER_OF_TLUTS_PER_INSTANCE;i++) {"+newLine);
		cfile.append("		XStatus Status;"+newLine);
		String withM = "";
		if(fpgaFamily.equals("virtex2pro"))
		    withM = "m";
		else if(fpgaFamily.equals("virtex5"))
		    withM = "";
		cfile.append("		Xuint32 ColNum = XHwIcap_"+withM+"SliceX2Col(location[i].lutCol);"+newLine);
		cfile.append("		Xuint32 RowNum = XHwIcap_"+withM+"SliceY2Row(HwIcap, location[i].lutRow);"+newLine);
		cfile.append("		Status = XHwIcap_SetClbBits(HwIcap, RowNum, ColNum, XHI_CLB_LUT.CONTENTS[location[i].sliceType][location[i].lutType], newtruthtables[i], LUT_CONFIG_WIDTH);"+newLine);
		cfile.append("	}"+newLine);
		
		cfile.append("}"+newLine+newLine);
		
		cfile.append("/*"+newLine);
		cfile.append("#include \""+headerFileName+"\""+newLine+newLine);
		cfile.append("int main(void) {"+newLine);
		if(fpgaFamily.equals("virtex2pro")) {
            cfile.append("	xil_printf(\"Starting EXOR test...\\n\\r\\n\\r\");"+newLine);
            cfile.append("	//Initialization"+newLine);
            cfile.append("	static XHwIcap HwIcap;"+newLine);
            cfile.append("	XHwIcap_Initialize(&HwIcap, HWICAP_DEVICEID, XHI_TARGET_DEVICEID);"+newLine);
            cfile.append("	//Run-time reconfiguration"+newLine);
            cfile.append("	Xuint8 i;"+newLine);
            cfile.append("	Xuint8 parameter[NUMBER_OF_PARAMETERS];"+newLine);
            cfile.append("	Xuint8 output[NUMBER_OF_INSTANCES][LUT_CONFIG_WIDTH];"+newLine);
            cfile.append("	xil_printf(\"Configuring the LUTs for p=0...\\n\\r\");"+newLine);
            cfile.append("	for (i=0;i<NUMBER_OF_INSTANCES;i++) {"+newLine);
            cfile.append("		//Reconfigure one instance"+newLine);
            cfile.append("		parameter[0]=0;"+newLine);
            cfile.append("		evaluate(parameter,output);"+newLine);
            cfile.append("		reconfigure(&HwIcap,output,location_array[i]);"+newLine);
            cfile.append("	}"+newLine);
            cfile.append("	xil_printf(\"Configuration Complete!\\n\\r\\n\\r\");"+newLine);
            cfile.append("	//Testing configuration"+newLine);
            cfile.append("	xil_printf(\"Writing 0xDEADBEAF to input register...\\n\\r\");"+newLine);
            cfile.append("	XIo_Out32(XPAR_OPB_XOR_0_BASEADDR,0xDEADBEAF);"+newLine);
            cfile.append("	xil_printf(\"Reading output register: %x\\n\\r\\n\\r\",XIo_In32(XPAR_OPB_XOR_0_BASEADDR+4));"+newLine);
            cfile.append("	xil_printf(\"End EXOR test.\\n\\r\\n\\r\");"+newLine);
            cfile.append("	return 1;"+newLine);
		} else {
            cfile.append("	xil_printf(\"Starting EXOR test...\\n\\r\\n\\r\");"+newLine);
            cfile.append("	//Initialization"+newLine);
            cfile.append("	static XHwIcap HwIcap;"+newLine);
            cfile.append("	XHwIcap_Config *CfgPtr = XHwIcap_LookupConfig(HWICAP_DEVICEID);"+newLine);
            cfile.append("	if (CfgPtr == NULL) return XST_FAILURE;"+newLine);
            cfile.append("	int Status = XHwIcap_CfgInitialize(&HwIcap, CfgPtr, CfgPtr->BaseAddress);"+newLine);
            cfile.append("	if (Status != XST_SUCCESS) return XST_FAILURE;"+newLine);
            cfile.append("	//Perform a self-test to ensure that the hardware was built correctly."+newLine);
            cfile.append("	Status = XHwIcap_SelfTest(&HwIcap);"+newLine);
            cfile.append("	if (Status != XST_SUCCESS) return XST_FAILURE;"+newLine);
            cfile.append("	//Run-time reconfiguration"+newLine);
            cfile.append("	Xuint8 i;"+newLine);
            cfile.append("	Xuint8 parameter[NUMBER_OF_PARAMETERS];"+newLine);
            cfile.append("	Xuint8 output[NUMBER_OF_INSTANCES][LUT_CONFIG_WIDTH];"+newLine);
            cfile.append("	xil_printf(\"Configuring the LUTs for p=0...\\n\\r\");"+newLine);
            cfile.append("	for (i=0;i<NUMBER_OF_INSTANCES;i++) {"+newLine);
            cfile.append("		//Reconfigure one instance"+newLine);
            cfile.append("		parameter[0]=0;"+newLine);
            cfile.append("		evaluate(parameter,output);"+newLine);
            cfile.append("		reconfigure(&HwIcap,output,location_array[i]);"+newLine);
            cfile.append("	}"+newLine);
            cfile.append("	xil_printf(\"Configuration Complete!\\n\\r\\n\\r\");"+newLine);
            cfile.append("	//Testing configuration"+newLine);
            cfile.append("	xil_printf(\"Writing 0xDEADBEAF to input register...\\n\\r\");"+newLine);
            cfile.append("	XIo_Out32(XPAR_PLB_XOR_0_BASEADDR,0xDEADBEAF);"+newLine);
            cfile.append("	xil_printf(\"Reading output register: %x\\n\\r\\n\\r\",XIo_In32(XPAR_PLB_XOR_0_BASEADDR+4));"+newLine);
            cfile.append("	xil_printf(\"End EXOR test.\\n\\r\\n\\r\");"+newLine);
            cfile.append("	return 1;"+newLine);

            
        }
		cfile.append("}"+newLine+"*/"+newLine);
		
		cstream.print(cfile.toString().replace("??", ""+max));
		cstream.flush();
		
		hstream.print(hfile.toString());
		hstream.flush();
		
		System.out.println("Maximum index: " + max);
	}
	
	public void merge(AIG<N,E> aig ) {
		AIG<N,E> copy = new AIG<N, E>(aig);
		
		this.and.addAll(copy.and);
		this.ilatch.addAll(copy.ilatch);
		this.latch.addAll(copy.latch);
		this.olatch.addAll(copy.olatch);
		copy.and.clear();
		
		
		this.const0.replace(copy.const0);
		
		Set<N> outputSet = new HashSet<N>(this.output);
		outputSet.addAll(copy.output);
		HashSet<N> inputSet = new HashSet<N>(this.input);
		inputSet.addAll(copy.input);
		Set<E> edgesSet = new HashSet<E>(this.edges);
		edgesSet.addAll(copy.edges);
		
		Map<String,N> findOutput = new HashMap<String,N>();
		for (N out:this.output) {
			findOutput.put(out.getName(), out);
		}
		
		for (N in : new ArrayList<N>(inputSet)) {
			if (findOutput.containsKey(in.getName())) {
				N out = findOutput.get(in.getName());
				E outEdge = out.getI0();
				N outDriver = outEdge.getTail();
				
				outDriver.removeOutput(outEdge);
				
				for (E e: in.getOutputEdges()) {
					e.setTail(outDriver);
					e.setInverted(e.isInverted() ^ outEdge.isInverted());
					outDriver.addOutput(e);
				}
				
				assert outputSet.contains(out);
				outputSet.remove(out);
				inputSet.remove(in);
				edgesSet.remove(outEdge);
			}
		}
		

		this.output = new ArrayList<N>(outputSet);
		this.input = new ArrayList<N>(inputSet);
		this.edges = new ArrayList<E>(edgesSet);
		
		sanityCheck();
	}
	
	public void removeUnusedNodes() {
		HashSet<N> unused_ands = new HashSet<N>(getAnds());
		unused_ands.removeAll(getAllVisibleAnds());
		ArrayList<E> unused_edges = new ArrayList<E>();
		for(N n : unused_ands) {
			for(E edge : n.getOutputEdges())
				if(!unused_ands.contains(edge.getHead()))
					throw new RuntimeException("Output of unused and is not unused: "+edge.getHead().getName());
			for(E edge : n.getInputEdges()) {
				edge.getTail().removeOutput(edge);
				//edges.remove(edge);
				unused_edges.add(edge);
			}
			//and.remove(n);
		}
		edges.removeAll(unused_edges);
		and.removeAll(unused_ands);
	}
	
	public void removeNode(N node) {
	    switch(node.getType()) {
		case AND:
			and.remove(node);
			break;
		case INPUT:
			input.remove(node);
			break;
		case OUTPUT:
			output.remove(node);
			break;
		case ILATCH:
			ilatch.remove(node);
			break;
		case LATCH:
			latch.remove(node);
			break;
		case OLATCH:
			olatch.remove(node);
			break;
		case CONST0:
			//Const0 is unique and cannot be removed
			break;
		default:
			System.out.println("Unknown node type!");
		}
	}
	
	public void removeEdge(E edge) {
		if(!edges.remove(edge))
			throw new RuntimeException("Trying to remove edge that doesn't exist");
	}

	public N addNode(String name, NodeType type) {
		N n = null;
		switch(type) {
		case AND:
			n = factory.newAnd(this);
			and.add(n);
			break;
		case INPUT:
			n = factory.newInput(this);
			input.add(n);
			break;
		case OUTPUT:
			n = factory.newOutput(this);
			output.add(n);
			break;
		case ILATCH:
			n = factory.newILatch(this);
			ilatch.add(n);
			break;
		case LATCH:
			n = factory.newLatch(this);
			latch.add(n);
			break;
		case OLATCH:
			n = factory.newOLatch(this);
			olatch.add(n);
			break;
		case CONST0:
			//Only one const0 instance may exist and is created on construction of the AIG
			n = getConst0();
			break;
		default:
			System.out.println("Unknown node type!");
		}
	
		n.setName(name);
		
		return n;
	}

	public E addEdge(N tail, N head, boolean inverted) {
		E e = factory.newEdge(tail, head, inverted);
		edges.add(e);
		return e;
	}

	public PolarisedNode<N> findNode(PolarisedNode<N> node0, PolarisedNode<N> node1) {
//		Constant propagation
		if (node1.getNode() == this.getConst0()) {
			PolarisedNode<N> swap_var = node1;
			node1 = node0;
			node0 = swap_var;
		}
		if (node0.getNode() == this.getConst0()) {
			if (node0.isInverted()) {
				return node1;
			} else {
				return new PolarisedNode<N>(this.getConst0(), false);
			}
//		No constant propagation possible
		} else {
			N n = strashMap.get(new StrashKey<N,E>(node0.getNode(), node0.isInverted(), node1.getNode(), node1.isInverted()));
			if (n == null)
				return null;
			else
				return new PolarisedNode<N>(n, false);
		}
//		return strashMap.get(new StrashKey<N,E>(node0, inv0, node1, inv1));
	}
	
	public N addNode(String name, PolarisedNode<N> node0, PolarisedNode<N> node1) {
		return addNode(name, node0.getNode(), node0.isInverted(),
			node1.getNode(), node1.isInverted());
	}

	public N addNode(String name, N node0, boolean inv0, N node1, boolean inv1) {
		N n = factory.newAnd(this);
		and.add(n);
		if(name != null)
			n.setName(name);
		else
			n.setName("n"+n.getID());
		
		E e = addEdge(node0, n, inv0);
		node0.addOutput(e);
		n.setI0(e);
		
		e = addEdge(node1, n, inv1);
		node1.addOutput(e);
		n.setI1(e);
		
		strashMap.put(new StrashKey<N, E>(node0, inv0, node1, inv1), n);

		return n;
	}
	
//	public void replaceNode(N old, N new_) {
//		for(E e : old.getOutputEdges()) {
//			E ne = addEdge(new_, e.getHead(), e.isInverted());
//			e.getHead().replaceInputEdge(e, ne);
//			new_.addOutput(ne);
//			removeEdge(e);
//		}
//		for(E e : old.getInputEdges()) {
//			E ne = addEdge(e.getTail(), new_, e.isInverted());
//			new_.addInput(ne);
//			e.getTail().removeOutput(e);
//			e.getTail().addOutput(ne); //e.getTail().replaceOutputEdge(e, ne);
//			removeEdge(e);
//		}
//		if(old.isGate() && old.getOutputEdges().size()==0)
//			removeNode(old);
//	}
	
    public void sortInputsAlphanumerically() {
        Collections.sort(input, new AlphanumNodeNameComparator());
    }
    
    public void sanityCheck() {
    	int num_output_edges = 0;
    	int num_input_edges = 0;
    	for(N n : getOLatches()) {
    		if(n.getI0() == null)
    			throw new RuntimeException("OLatch node "+n.toString()+" expects non-null input");
    		if(!n.getI0().getTail().isLatch())
    			throw new RuntimeException("OLatch node "+n.toString()+" expects Latch node as input");
    		if(n.getI0().isInverted())
    			throw new RuntimeException("OLatch node "+n.toString()+" input is not supposed to be inverted");
    	}
    	for(N n : getLatches()) {
    		if(n.getI0() == null)
    			throw new RuntimeException("Latch node "+n.toString()+" expects non-null input");
    		if(!n.getI0().getTail().isILatch())
    			throw new RuntimeException("Latch node "+n.toString()+" expects ILatch node as input");
    		if(n.getI0().isInverted())
    			throw new RuntimeException("Latch node "+n.toString()+" input is not supposed to be inverted");
    	}
    	for(N o : getOutputs())
    		if(o.getOutputEdges().size() != 0)
    			throw new RuntimeException("Output node "+o.toString()+" has an output edge");
    	HashSet<N> allNodes = new HashSet<N>(getAllNodes());
    	for(N n : getAllNodes()) {
    		for(E e : n.getOutputEdges()) {
    			num_output_edges++;
    			if(e == null)
    				throw new RuntimeException("Node "+n.toString()+" has null output edge");
    			if(e.getTail() != n)
    				throw new RuntimeException("Node "+n.toString()+" is not the tail of one of its output edges: "+e.toString());
    			N head = e.getHead();
    			if(head == null)
    				throw new RuntimeException("Head of edge "+e.toString()+" is null");
    			if(!head.getInputEdges().contains(e))
    				throw new RuntimeException("Edge "+e.toString()+" is not one of the input edges of its head");
    			if(!allNodes.contains(head))
    				throw new RuntimeException("Head of edge "+e.toString()+" is not a node of this AIG");
    		}
    		for(E e : n.getInputEdges()) {
    			num_input_edges++;
    			if(e == null)
    				throw new RuntimeException("Node "+n.toString()+" has null input edge");
    			if(e.getHead() != n)
    				throw new RuntimeException("Node "+n.toString()+" is not the head of one of its input edges: "+e.toString());
    			N tail = e.getTail();
    			if(tail == null)
    				throw new RuntimeException("Tail of edge "+e.toString()+" is null");
    			if(!tail.getOutputEdges().contains(e))
    				throw new RuntimeException("Edge "+e.toString()+" is not one of the output edges of its tail");
    			if(!allNodes.contains(tail))
    				throw new RuntimeException("Tail of edge "+e.toString()+" is not a node of this AIG");
    		}
    	}
    	if(num_output_edges != edges.size())
    		throw new RuntimeException("Number of output edges of nodes does not equal number of edges of AIG");
    	if(num_input_edges != edges.size())
    		throw new RuntimeException("Number of input edges of nodes does not equal number of edges of AIG");
    }
    
    public void strashCheck() {
    	strashMap.clear();
    	
    	for(N n : getAnds()) {
    		if(n.getOutputEdges().size() == 0)
    			throw new RuntimeException("AND should have at least one output");
    		for(E e : n.getInputEdges()) {
    			if(e.getTail().isConst0())
    				throw new RuntimeException("Input of AND should not be Const0");
    		}
    		if(n.getI0().equals(n.getI1()))
    			throw new RuntimeException("AND should have two different inputs");
    		
    		StrashKey<N,E> key = new StrashKey<N,E>(n.getI0().getTail(), n.getI0().isInverted(),
    												n.getI1().getTail(), n.getI1().isInverted());
    		if(strashMap.get(key) != null)
    			throw new RuntimeException("AND node with same strashkey already exists");
    		strashMap.put(key, n);
    	}
    }

	
	public float getAvgBDDSize() {
        int numCones = 0;
        int sumBddSize = 0;
        for(N n : getAllNodes()) {
        	for(Cone cone : ((Node)(Object)n).getConeSet().getCones()) {
	    		sumBddSize += cone.getLocalFunction().nodeCount();
	    		numCones += 1;
        	}
        }
        return sumBddSize/(float)(numCones);
	}
}
